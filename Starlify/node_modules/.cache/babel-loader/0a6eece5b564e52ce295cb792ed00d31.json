{"ast":null,"code":"/*!\n * @pixi/canvas-graphics - v5.0.4\n * Compiled Fri, 07 Jun 2019 17:17:49 UTC\n *\n * @pixi/canvas-graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasGraphicsRenderer = function CanvasGraphicsRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders a Graphics object to a canvas.\n *\n * @param {PIXI.Graphics} graphics - the actual graphics object to render\n */\n\n\nCanvasGraphicsRenderer.prototype.render = function render(graphics) {\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var worldAlpha = graphics.worldAlpha;\n  var transform = graphics.transform.worldTransform;\n  var resolution = renderer.resolution;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); // update tint if graphics was dirty\n\n  if (graphics.canvasTintDirty !== graphics.dirty || graphics._prevTint !== graphics.tint) ;\n  renderer.setBlendMode(graphics.blendMode);\n  var graphicsData = graphics.geometry.graphicsData;\n\n  for (var i = 0; i < graphicsData.length; i++) {\n    var data = graphicsData[i];\n    var shape = data.shape;\n    var fillStyle = data.fillStyle;\n    var lineStyle = data.lineStyle;\n    var fillColor = fillStyle.color; // data._fillTint;\n\n    var lineColor = lineStyle.color; // data._lineTint;\n\n    context.lineWidth = lineStyle.width;\n\n    if (data.type === SHAPES.POLY) {\n      context.beginPath();\n      var points = shape.points;\n      var holes = data.holes;\n      var outerArea = void 0;\n      var innerArea = void 0;\n      var px = void 0;\n      var py = void 0;\n      context.moveTo(points[0], points[1]);\n\n      for (var j = 2; j < points.length; j += 2) {\n        context.lineTo(points[j], points[j + 1]);\n      }\n\n      if (shape.closeStroke) {\n        context.closePath();\n      }\n\n      if (holes.length > 0) {\n        outerArea = 0;\n        px = points[0];\n        py = points[1];\n\n        for (var j$1 = 2; j$1 + 2 < points.length; j$1 += 2) {\n          outerArea += (points[j$1] - px) * (points[j$1 + 3] - py) - (points[j$1 + 2] - px) * (points[j$1 + 1] - py);\n        }\n\n        for (var k = 0; k < holes.length; k++) {\n          points = holes[k].shape.points;\n\n          if (!points) {\n            continue;\n          }\n\n          innerArea = 0;\n          px = points[0];\n          py = points[1];\n\n          for (var j$2 = 2; j$2 + 2 < points.length; j$2 += 2) {\n            innerArea += (points[j$2] - px) * (points[j$2 + 3] - py) - (points[j$2 + 2] - px) * (points[j$2 + 1] - py);\n          }\n\n          if (innerArea * outerArea < 0) {\n            context.moveTo(points[0], points[1]);\n\n            for (var j$3 = 2; j$3 < points.length; j$3 += 2) {\n              context.lineTo(points[j$3], points[j$3 + 1]);\n            }\n          } else {\n            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n            for (var j$4 = points.length - 4; j$4 >= 0; j$4 -= 2) {\n              context.lineTo(points[j$4], points[j$4 + 1]);\n            }\n          }\n\n          if (holes[k].shape.closeStroke) {\n            context.closePath();\n          }\n        }\n      }\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.RECT) {\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fillRect(shape.x, shape.y, shape.width, shape.height);\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n      }\n    } else if (data.type === SHAPES.CIRC) {\n      // TODO - need to be Undefined!\n      context.beginPath();\n      context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.ELIP) {\n      // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n      var w = shape.width * 2;\n      var h = shape.height * 2;\n      var x = shape.x - w / 2;\n      var y = shape.y - h / 2;\n      context.beginPath();\n      var kappa = 0.5522848;\n      var ox = w / 2 * kappa; // control point offset horizontal\n\n      var oy = h / 2 * kappa; // control point offset vertical\n\n      var xe = x + w; // x-end\n\n      var ye = y + h; // y-end\n\n      var xm = x + w / 2; // x-middle\n\n      var ym = y + h / 2; // y-middle\n\n      context.moveTo(x, ym);\n      context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n      context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n      context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n      context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.RREC) {\n      var rx = shape.x;\n      var ry = shape.y;\n      var width = shape.width;\n      var height = shape.height;\n      var radius = shape.radius;\n      var maxRadius = Math.min(width, height) / 2 | 0;\n      radius = radius > maxRadius ? maxRadius : radius;\n      context.beginPath();\n      context.moveTo(rx, ry + radius);\n      context.lineTo(rx, ry + height - radius);\n      context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n      context.lineTo(rx + width - radius, ry + height);\n      context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n      context.lineTo(rx + width, ry + radius);\n      context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n      context.lineTo(rx + radius, ry);\n      context.quadraticCurveTo(rx, ry, rx, ry + radius);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    }\n  }\n};\n/**\n * Updates the tint of a graphics object\n *\n * @protected\n * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated\n */\n\n\nCanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {\n  graphics._prevTint = graphics.tint;\n  graphics.canvasTintDirty = graphics.dirty;\n  var tintR = (graphics.tint >> 16 & 0xFF) / 255;\n  var tintG = (graphics.tint >> 8 & 0xFF) / 255;\n  var tintB = (graphics.tint & 0xFF) / 255;\n\n  for (var i = 0; i < graphics.graphicsData.length; ++i) {\n    var data = graphics.graphicsData[i];\n    var fillColor = data.fillColor | 0;\n    var lineColor = data.lineColor | 0; // super inline, cos optimization :)\n\n    data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;\n    data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;\n  }\n};\n/**\n * destroy graphics object\n *\n */\n\n\nCanvasGraphicsRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n\nvar canvasRenderer;\nvar tempMatrix = new Matrix();\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {number} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\n\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {\n  if (resolution === void 0) resolution = 1;\n  var bounds = this.getLocalBounds();\n  var canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n  if (!canvasRenderer) {\n    canvasRenderer = new CanvasRenderer();\n  }\n\n  this.transform.updateLocalTransform();\n  this.transform.localTransform.copyTo(tempMatrix);\n  tempMatrix.invert();\n  tempMatrix.tx -= bounds.x;\n  tempMatrix.ty -= bounds.y;\n  canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n  var texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n    scaleMode: scaleMode\n  });\n  texture.baseTexture.resolution = resolution;\n  texture.baseTexture.update();\n  return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\n\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.isMask === true) {\n    return;\n  }\n\n  this.finishPoly();\n  renderer.plugins.graphics.render(this);\n};\n\nexport { CanvasGraphicsRenderer };","map":null,"metadata":{},"sourceType":"module"}