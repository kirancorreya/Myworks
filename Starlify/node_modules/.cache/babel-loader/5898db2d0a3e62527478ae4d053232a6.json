{"ast":null,"code":"/*!\n * @pixi/loaders - v5.0.4\n * Compiled Fri, 07 Jun 2019 17:17:49 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport ResourceLoader, { Resource } from 'resource-loader';\nimport { EventEmitter } from '@pixi/utils';\nimport { Texture } from '@pixi/core';\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar parseUri = function parseURI(str, opts) {\n  opts = opts || {};\n  var o = {\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n    q: {\n      name: 'queryKey',\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    uri[o.key[i]] = m[i] || '';\n  }\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) {\n      uri[o.q.name][$1] = $2;\n    }\n  });\n  return uri;\n};\n\nvar miniSignals = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n\n        if ('value' in descriptor) {\n          descriptor.writable = true;\n        }\n\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) {\n        defineProperties(Constructor.prototype, protoProps);\n      }\n\n      if (staticProps) {\n        defineProperties(Constructor, staticProps);\n      }\n\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  var MiniSignalBinding = function () {\n    function MiniSignalBinding(fn, once, thisArg) {\n      if (once === undefined) {\n        once = false;\n      }\n\n      _classCallCheck(this, MiniSignalBinding);\n\n      this._fn = fn;\n      this._once = once;\n      this._thisArg = thisArg;\n      this._next = this._prev = this._owner = null;\n    }\n\n    _createClass(MiniSignalBinding, [{\n      key: 'detach',\n      value: function detach() {\n        if (this._owner === null) {\n          return false;\n        }\n\n        this._owner.detach(this);\n\n        return true;\n      }\n    }]);\n\n    return MiniSignalBinding;\n  }();\n\n  function _addMiniSignalBinding(self, node) {\n    if (!self._head) {\n      self._head = node;\n      self._tail = node;\n    } else {\n      self._tail._next = node;\n      node._prev = self._tail;\n      self._tail = node;\n    }\n\n    node._owner = self;\n    return node;\n  }\n\n  var MiniSignal = function () {\n    function MiniSignal() {\n      _classCallCheck(this, MiniSignal);\n\n      this._head = this._tail = undefined;\n    }\n\n    _createClass(MiniSignal, [{\n      key: 'handlers',\n      value: function handlers() {\n        var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n        var node = this._head;\n\n        if (exists) {\n          return !!node;\n        }\n\n        var ee = [];\n\n        while (node) {\n          ee.push(node);\n          node = node._next;\n        }\n\n        return ee;\n      }\n    }, {\n      key: 'has',\n      value: function has(node) {\n        if (!(node instanceof MiniSignalBinding)) {\n          throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');\n        }\n\n        return node._owner === this;\n      }\n    }, {\n      key: 'dispatch',\n      value: function dispatch() {\n        var arguments$1 = arguments;\n        var node = this._head;\n\n        if (!node) {\n          return false;\n        }\n\n        while (node) {\n          if (node._once) {\n            this.detach(node);\n          }\n\n          node._fn.apply(node._thisArg, arguments$1);\n\n          node = node._next;\n        }\n\n        return true;\n      }\n    }, {\n      key: 'add',\n      value: function add(fn) {\n        var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n        if (typeof fn !== 'function') {\n          throw new Error('MiniSignal#add(): First arg must be a Function.');\n        }\n\n        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));\n      }\n    }, {\n      key: 'once',\n      value: function once(fn) {\n        var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n        if (typeof fn !== 'function') {\n          throw new Error('MiniSignal#once(): First arg must be a Function.');\n        }\n\n        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));\n      }\n    }, {\n      key: 'detach',\n      value: function detach(node) {\n        if (!(node instanceof MiniSignalBinding)) {\n          throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');\n        }\n\n        if (node._owner !== this) {\n          return this;\n        }\n\n        if (node._prev) {\n          node._prev._next = node._next;\n        }\n\n        if (node._next) {\n          node._next._prev = node._prev;\n        }\n\n        if (node === this._head) {\n          this._head = node._next;\n\n          if (node._next === null) {\n            this._tail = null;\n          }\n        } else if (node === this._tail) {\n          this._tail = node._prev;\n          this._tail._next = null;\n        }\n\n        node._owner = null;\n        return this;\n      }\n    }, {\n      key: 'detachAll',\n      value: function detachAll() {\n        var node = this._head;\n\n        if (!node) {\n          return this;\n        }\n\n        this._head = this._tail = null;\n\n        while (node) {\n          node._owner = null;\n          node = node._next;\n        }\n\n        return this;\n      }\n    }]);\n\n    return MiniSignal;\n  }();\n\n  MiniSignal.MiniSignalBinding = MiniSignalBinding;\n  exports['default'] = MiniSignal;\n  module.exports = exports['default'];\n});\nunwrapExports(miniSignals);\nvar Resource_1 = createCommonjsModule(function (module, exports) {\n  exports.__esModule = true;\n  exports.Resource = undefined;\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n\n        if (\"value\" in descriptor) {\n          descriptor.writable = true;\n        }\n\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) {\n        defineProperties(Constructor.prototype, protoProps);\n      }\n\n      if (staticProps) {\n        defineProperties(Constructor, staticProps);\n      }\n\n      return Constructor;\n    };\n  }();\n\n  var _parseUri2 = _interopRequireDefault(parseUri);\n\n  var _miniSignals2 = _interopRequireDefault(miniSignals);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  } // tests if CORS is supported in XHR, if not we need to use XDR\n\n\n  var useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\n  var tempAnchor = null; // some status constants\n\n  var STATUS_NONE = 0;\n  var STATUS_OK = 200;\n  var STATUS_EMPTY = 204;\n  var STATUS_IE_BUG_EMPTY = 1223;\n  var STATUS_TYPE_OK = 2; // noop\n\n  function _noop() {}\n  /* empty */\n\n  /**\n   * Manages the state and loading of a resource and all child resources.\n   *\n   * @class\n   */\n\n\n  var Resource = exports.Resource = function () {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {\n      setExtMap(Resource._loadTypeMap, extname, loadType);\n    };\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n\n\n    Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {\n      setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    };\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n\n\n    function Resource(name, url, options) {\n      _classCallCheck(this, Resource);\n\n      if (typeof name !== 'string' || typeof url !== 'string') {\n        throw new Error('Both name and url are required for constructing a resource.');\n      }\n\n      options = options || {};\n      /**\n       * The state flags of this resource.\n       *\n       * @private\n       * @member {number}\n       */\n\n      this._flags = 0; // set data url flag, needs to be set early for some _determineX checks to work.\n\n      this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n      /**\n       * The name of this resource.\n       *\n       * @readonly\n       * @member {string}\n       */\n\n\n      this.name = name;\n      /**\n       * The url used to load this resource.\n       *\n       * @readonly\n       * @member {string}\n       */\n\n      this.url = url;\n      /**\n       * The extension used to load this resource.\n       *\n       * @readonly\n       * @member {string}\n       */\n\n      this.extension = this._getExtension();\n      /**\n       * The data that was loaded by the resource.\n       *\n       * @member {any}\n       */\n\n      this.data = null;\n      /**\n       * Is this request cross-origin? If unset, determined automatically.\n       *\n       * @member {string}\n       */\n\n      this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n      /**\n       * A timeout in milliseconds for the load. If the load takes longer than this time\n       * it is cancelled and the load is considered a failure. If this value is set to `0`\n       * then there is no explicit timeout.\n       *\n       * @member {number}\n       */\n\n      this.timeout = options.timeout || 0;\n      /**\n       * The method of loading to use for this resource.\n       *\n       * @member {Resource.LOAD_TYPE}\n       */\n\n      this.loadType = options.loadType || this._determineLoadType();\n      /**\n       * The type used to load the resource via XHR. If unset, determined automatically.\n       *\n       * @member {string}\n       */\n\n      this.xhrType = options.xhrType;\n      /**\n       * Extra info for middleware, and controlling specifics about how the resource loads.\n       *\n       * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n       * Meaning it will modify it as it sees fit.\n       *\n       * @member {Resource.IMetadata}\n       */\n\n      this.metadata = options.metadata || {};\n      /**\n       * The error that occurred while loading (if any).\n       *\n       * @readonly\n       * @member {Error}\n       */\n\n      this.error = null;\n      /**\n       * The XHR object that was used to load this resource. This is only set\n       * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n       *\n       * @readonly\n       * @member {XMLHttpRequest}\n       */\n\n      this.xhr = null;\n      /**\n       * The child resources this resource owns.\n       *\n       * @readonly\n       * @member {Resource[]}\n       */\n\n      this.children = [];\n      /**\n       * The resource type.\n       *\n       * @readonly\n       * @member {Resource.TYPE}\n       */\n\n      this.type = Resource.TYPE.UNKNOWN;\n      /**\n       * The progress chunk owned by this resource.\n       *\n       * @readonly\n       * @member {number}\n       */\n\n      this.progressChunk = 0;\n      /**\n       * The `dequeue` method that will be used a storage place for the async queue dequeue method\n       * used privately by the loader.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._dequeue = _noop;\n      /**\n       * Used a storage place for the on load binding used privately by the loader.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._onLoadBinding = null;\n      /**\n       * The timer for element loads to check if they timeout.\n       *\n       * @private\n       * @member {number}\n       */\n\n      this._elementTimer = 0;\n      /**\n       * The `complete` function bound to this resource's context.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._boundComplete = this.complete.bind(this);\n      /**\n       * The `_onError` function bound to this resource's context.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._boundOnError = this._onError.bind(this);\n      /**\n       * The `_onProgress` function bound to this resource's context.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._boundOnProgress = this._onProgress.bind(this);\n      /**\n       * The `_onTimeout` function bound to this resource's context.\n       *\n       * @private\n       * @member {function}\n       */\n\n      this._boundOnTimeout = this._onTimeout.bind(this); // xhr callbacks\n\n      this._boundXhrOnError = this._xhrOnError.bind(this);\n      this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n      this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n      this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n      /**\n       * Dispatched when the resource beings to load.\n       *\n       * The callback looks like {@link Resource.OnStartSignal}.\n       *\n       * @member {Signal<Resource.OnStartSignal>}\n       */\n\n      this.onStart = new _miniSignals2.default();\n      /**\n       * Dispatched each time progress of this resource load updates.\n       * Not all resources types and loader systems can support this event\n       * so sometimes it may not be available. If the resource\n       * is being loaded on a modern browser, using XHR, and the remote server\n       * properly sets Content-Length headers, then this will be available.\n       *\n       * The callback looks like {@link Resource.OnProgressSignal}.\n       *\n       * @member {Signal<Resource.OnProgressSignal>}\n       */\n\n      this.onProgress = new _miniSignals2.default();\n      /**\n       * Dispatched once this resource has loaded, if there was an error it will\n       * be in the `error` property.\n       *\n       * The callback looks like {@link Resource.OnCompleteSignal}.\n       *\n       * @member {Signal<Resource.OnCompleteSignal>}\n       */\n\n      this.onComplete = new _miniSignals2.default();\n      /**\n       * Dispatched after this resource has had all the *after* middleware run on it.\n       *\n       * The callback looks like {@link Resource.OnCompleteSignal}.\n       *\n       * @member {Signal<Resource.OnCompleteSignal>}\n       */\n\n      this.onAfterMiddleware = new _miniSignals2.default();\n    }\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n\n\n    Resource.prototype.complete = function complete() {\n      this._clearEvents();\n\n      this._finish();\n    };\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n\n\n    Resource.prototype.abort = function abort(message) {\n      // abort can be called multiple times, ignore subsequent calls.\n      if (this.error) {\n        return;\n      } // store error\n\n\n      this.error = new Error(message); // clear events before calling aborts\n\n      this._clearEvents(); // abort the actual loading\n\n\n      if (this.xhr) {\n        this.xhr.abort();\n      } else if (this.xdr) {\n        this.xdr.abort();\n      } else if (this.data) {\n        // single source\n        if (this.data.src) {\n          this.data.src = Resource.EMPTY_GIF;\n        } // multi-source\n        else {\n            while (this.data.firstChild) {\n              this.data.removeChild(this.data.firstChild);\n            }\n          }\n      } // done now.\n\n\n      this._finish();\n    };\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n\n\n    Resource.prototype.load = function load(cb) {\n      var _this = this;\n\n      if (this.isLoading) {\n        return;\n      }\n\n      if (this.isComplete) {\n        if (cb) {\n          setTimeout(function () {\n            return cb(_this);\n          }, 1);\n        }\n\n        return;\n      } else if (cb) {\n        this.onComplete.once(cb);\n      }\n\n      this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n      this.onStart.dispatch(this); // if unset, determine the value\n\n      if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n        this.crossOrigin = this._determineCrossOrigin(this.url);\n      }\n\n      switch (this.loadType) {\n        case Resource.LOAD_TYPE.IMAGE:\n          this.type = Resource.TYPE.IMAGE;\n\n          this._loadElement('image');\n\n          break;\n\n        case Resource.LOAD_TYPE.AUDIO:\n          this.type = Resource.TYPE.AUDIO;\n\n          this._loadSourceElement('audio');\n\n          break;\n\n        case Resource.LOAD_TYPE.VIDEO:\n          this.type = Resource.TYPE.VIDEO;\n\n          this._loadSourceElement('video');\n\n          break;\n\n        case Resource.LOAD_TYPE.XHR:\n        /* falls through */\n\n        default:\n          if (useXdr && this.crossOrigin) {\n            this._loadXdr();\n          } else {\n            this._loadXhr();\n          }\n\n          break;\n      }\n    };\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n\n\n    Resource.prototype._hasFlag = function _hasFlag(flag) {\n      return (this._flags & flag) !== 0;\n    };\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n\n\n    Resource.prototype._setFlag = function _setFlag(flag, value) {\n      this._flags = value ? this._flags | flag : this._flags & ~flag;\n    };\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._clearEvents = function _clearEvents() {\n      clearTimeout(this._elementTimer);\n\n      if (this.data && this.data.removeEventListener) {\n        this.data.removeEventListener('error', this._boundOnError, false);\n        this.data.removeEventListener('load', this._boundComplete, false);\n        this.data.removeEventListener('progress', this._boundOnProgress, false);\n        this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n      }\n\n      if (this.xhr) {\n        if (this.xhr.removeEventListener) {\n          this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n          this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n          this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n          this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n          this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n        } else {\n          this.xhr.onerror = null;\n          this.xhr.ontimeout = null;\n          this.xhr.onprogress = null;\n          this.xhr.onload = null;\n        }\n      }\n    };\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._finish = function _finish() {\n      if (this.isComplete) {\n        throw new Error('Complete called again for an already completed resource.');\n      }\n\n      this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n\n      this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n      this.onComplete.dispatch(this);\n    };\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n\n\n    Resource.prototype._loadElement = function _loadElement(type) {\n      if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n      } else if (type === 'image' && typeof window.Image !== 'undefined') {\n        this.data = new Image();\n      } else {\n        this.data = document.createElement(type);\n      }\n\n      if (this.crossOrigin) {\n        this.data.crossOrigin = this.crossOrigin;\n      }\n\n      if (!this.metadata.skipSource) {\n        this.data.src = this.url;\n      }\n\n      this.data.addEventListener('error', this._boundOnError, false);\n      this.data.addEventListener('load', this._boundComplete, false);\n      this.data.addEventListener('progress', this._boundOnProgress, false);\n\n      if (this.timeout) {\n        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n      }\n    };\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n\n\n    Resource.prototype._loadSourceElement = function _loadSourceElement(type) {\n      if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n      } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n        this.data = new Audio();\n      } else {\n        this.data = document.createElement(type);\n      }\n\n      if (this.data === null) {\n        this.abort('Unsupported element: ' + type);\n        return;\n      }\n\n      if (this.crossOrigin) {\n        this.data.crossOrigin = this.crossOrigin;\n      }\n\n      if (!this.metadata.skipSource) {\n        // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n        if (navigator.isCocoonJS) {\n          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n        } else if (Array.isArray(this.url)) {\n          var mimeTypes = this.metadata.mimeType;\n\n          for (var i = 0; i < this.url.length; ++i) {\n            this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n          }\n        } else {\n          var _mimeTypes = this.metadata.mimeType;\n          this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));\n        }\n      }\n\n      this.data.addEventListener('error', this._boundOnError, false);\n      this.data.addEventListener('load', this._boundComplete, false);\n      this.data.addEventListener('progress', this._boundOnProgress, false);\n      this.data.addEventListener('canplaythrough', this._boundComplete, false);\n      this.data.load();\n\n      if (this.timeout) {\n        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n      }\n    };\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._loadXhr = function _loadXhr() {\n      // if unset, determine the value\n      if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n      }\n\n      var xhr = this.xhr = new XMLHttpRequest(); // set the request type and url\n\n      xhr.open('GET', this.url, true);\n      xhr.timeout = this.timeout; // load json as text and parse it ourselves. We do this because some browsers\n      // *cough* safari *cough* can't deal with it.\n\n      if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n      } else {\n        xhr.responseType = this.xhrType;\n      }\n\n      xhr.addEventListener('error', this._boundXhrOnError, false);\n      xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n      xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n      xhr.addEventListener('progress', this._boundOnProgress, false);\n      xhr.addEventListener('load', this._boundXhrOnLoad, false);\n      xhr.send();\n    };\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n\n\n    Resource.prototype._loadXdr = function _loadXdr() {\n      // if unset, determine the value\n      if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n      }\n\n      var xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n      // XDomainRequest has a few quirks. Occasionally it will abort requests\n      // A way to avoid this is to make sure ALL callbacks are set even if not used\n      // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n      xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n      xdr.onerror = this._boundXhrOnError;\n      xdr.ontimeout = this._boundXhrOnTimeout;\n      xdr.onprogress = this._boundOnProgress;\n      xdr.onload = this._boundXhrOnLoad;\n      xdr.open('GET', this.url, true); // Note: The xdr.send() call is wrapped in a timeout to prevent an\n      // issue with the interface where some requests are lost if multiple\n      // XDomainRequests are being sent at the same time.\n      // Some info here: https://github.com/photonstorm/phaser/issues/1248\n\n      setTimeout(function () {\n        return xdr.send();\n      }, 1);\n    };\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n\n\n    Resource.prototype._createSource = function _createSource(type, url, mime) {\n      if (!mime) {\n        mime = type + '/' + this._getExtension(url);\n      }\n\n      var source = document.createElement('source');\n      source.src = url;\n      source.type = mime;\n      return source;\n    };\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n\n\n    Resource.prototype._onError = function _onError(event) {\n      this.abort('Failed to load element using: ' + event.target.nodeName);\n    };\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n\n\n    Resource.prototype._onProgress = function _onProgress(event) {\n      if (event && event.lengthComputable) {\n        this.onProgress.dispatch(this, event.loaded / event.total);\n      }\n    };\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._onTimeout = function _onTimeout() {\n      this.abort('Load timed out.');\n    };\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._xhrOnError = function _xhrOnError() {\n      var xhr = this.xhr;\n      this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n    };\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._xhrOnTimeout = function _xhrOnTimeout() {\n      var xhr = this.xhr;\n      this.abort(reqType(xhr) + ' Request timed out.');\n    };\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n\n\n    Resource.prototype._xhrOnAbort = function _xhrOnAbort() {\n      var xhr = this.xhr;\n      this.abort(reqType(xhr) + ' Request was aborted by the user.');\n    };\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n\n\n    Resource.prototype._xhrOnLoad = function _xhrOnLoad() {\n      var xhr = this.xhr;\n      var text = '';\n      var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n      // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\n      if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n        text = xhr.responseText;\n      } // status can be 0 when using the `file://` protocol so we also check if a response is set.\n      // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n\n\n      if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n        status = STATUS_OK;\n      } // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n      else if (status === STATUS_IE_BUG_EMPTY) {\n          status = STATUS_EMPTY;\n        }\n\n      var statusType = status / 100 | 0;\n\n      if (statusType === STATUS_TYPE_OK) {\n        // if text, just return it\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n          this.data = text;\n          this.type = Resource.TYPE.TEXT;\n        } // if json, parse into json object\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n            try {\n              this.data = JSON.parse(text);\n              this.type = Resource.TYPE.JSON;\n            } catch (e) {\n              this.abort('Error trying to parse loaded json: ' + e);\n              return;\n            }\n          } // if xml, parse into an xml document or div element\n          else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n              try {\n                if (window.DOMParser) {\n                  var domparser = new DOMParser();\n                  this.data = domparser.parseFromString(text, 'text/xml');\n                } else {\n                  var div = document.createElement('div');\n                  div.innerHTML = text;\n                  this.data = div;\n                }\n\n                this.type = Resource.TYPE.XML;\n              } catch (e) {\n                this.abort('Error trying to parse loaded xml: ' + e);\n                return;\n              }\n            } // other types just return the response\n            else {\n                this.data = xhr.response || text;\n              }\n      } else {\n        this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);\n        return;\n      }\n\n      this.complete();\n    };\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n\n\n    Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {\n      // data: and javascript: urls are considered same-origin\n      if (url.indexOf('data:') === 0) {\n        return '';\n      } // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n      // origin designed not to match window.location.origin, and will always require\n      // crossOrigin requests regardless of whether the location matches.\n\n\n      if (window.origin !== window.location.origin) {\n        return 'anonymous';\n      } // default is window.location\n\n\n      loc = loc || window.location;\n\n      if (!tempAnchor) {\n        tempAnchor = document.createElement('a');\n      } // let the browser determine the full href for the url of this resource and then\n      // parse with the node url lib, we can't use the properties of the anchor element\n      // because they don't work in IE9 :(\n\n\n      tempAnchor.href = url;\n      url = (0, _parseUri2.default)(tempAnchor.href, {\n        strictMode: true\n      });\n      var samePort = !url.port && loc.port === '' || url.port === loc.port;\n      var protocol = url.protocol ? url.protocol + ':' : ''; // if cross origin\n\n      if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n        return 'anonymous';\n      }\n\n      return '';\n    };\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n\n\n    Resource.prototype._determineXhrType = function _determineXhrType() {\n      return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    };\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n\n\n    Resource.prototype._determineLoadType = function _determineLoadType() {\n      return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    };\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n\n\n    Resource.prototype._getExtension = function _getExtension() {\n      var url = this.url;\n      var ext = '';\n\n      if (this.isDataUrl) {\n        var slashIndex = url.indexOf('/');\n        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n      } else {\n        var queryStart = url.indexOf('?');\n        var hashStart = url.indexOf('#');\n        var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n        url = url.substring(0, index);\n        ext = url.substring(url.lastIndexOf('.') + 1);\n      }\n\n      return ext.toLowerCase();\n    };\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n\n\n    Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {\n      switch (type) {\n        case Resource.XHR_RESPONSE_TYPE.BUFFER:\n          return 'application/octet-binary';\n\n        case Resource.XHR_RESPONSE_TYPE.BLOB:\n          return 'application/blob';\n\n        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n          return 'application/xml';\n\n        case Resource.XHR_RESPONSE_TYPE.JSON:\n          return 'application/json';\n\n        case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n        case Resource.XHR_RESPONSE_TYPE.TEXT:\n        /* falls through */\n\n        default:\n          return 'text/plain';\n      }\n    };\n\n    _createClass(Resource, [{\n      key: 'isDataUrl',\n      get: function get() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n      }\n      /**\n       * Describes if this resource has finished loading. Is true when the resource has completely\n       * loaded.\n       *\n       * @readonly\n       * @member {boolean}\n       */\n\n    }, {\n      key: 'isComplete',\n      get: function get() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n      }\n      /**\n       * Describes if this resource is currently loading. Is true when the resource starts loading,\n       * and is false again when complete.\n       *\n       * @readonly\n       * @member {boolean}\n       */\n\n    }, {\n      key: 'isLoading',\n      get: function get() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n      }\n    }]);\n\n    return Resource;\n  }();\n  /**\n   * The types of resources a resource could represent.\n   *\n   * @static\n   * @readonly\n   * @enum {number}\n   */\n\n\n  Resource.STATUS_FLAGS = {\n    NONE: 0,\n    DATA_URL: 1 << 0,\n    COMPLETE: 1 << 1,\n    LOADING: 1 << 2\n  };\n  /**\n   * The types of resources a resource could represent.\n   *\n   * @static\n   * @readonly\n   * @enum {number}\n   */\n\n  Resource.TYPE = {\n    UNKNOWN: 0,\n    JSON: 1,\n    XML: 2,\n    IMAGE: 3,\n    AUDIO: 4,\n    VIDEO: 5,\n    TEXT: 6\n  };\n  /**\n   * The types of loading a resource can use.\n   *\n   * @static\n   * @readonly\n   * @enum {number}\n   */\n\n  Resource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR: 1,\n\n    /** Uses an `Image` object to load the resource. */\n    IMAGE: 2,\n\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO: 3,\n\n    /** Uses a `Video` object to load the resource. */\n    VIDEO: 4\n  };\n  /**\n   * The XHR ready states, used internally.\n   *\n   * @static\n   * @readonly\n   * @enum {string}\n   */\n\n  Resource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT: 'text',\n\n    /** ArrayBuffer */\n    BUFFER: 'arraybuffer',\n\n    /** Blob */\n    BLOB: 'blob',\n\n    /** Document */\n    DOCUMENT: 'document',\n\n    /** Object */\n    JSON: 'json',\n\n    /** String */\n    TEXT: 'text'\n  };\n  Resource._loadTypeMap = {\n    // images\n    gif: Resource.LOAD_TYPE.IMAGE,\n    png: Resource.LOAD_TYPE.IMAGE,\n    bmp: Resource.LOAD_TYPE.IMAGE,\n    jpg: Resource.LOAD_TYPE.IMAGE,\n    jpeg: Resource.LOAD_TYPE.IMAGE,\n    tif: Resource.LOAD_TYPE.IMAGE,\n    tiff: Resource.LOAD_TYPE.IMAGE,\n    webp: Resource.LOAD_TYPE.IMAGE,\n    tga: Resource.LOAD_TYPE.IMAGE,\n    svg: Resource.LOAD_TYPE.IMAGE,\n    'svg+xml': Resource.LOAD_TYPE.IMAGE,\n    // for SVG data urls\n    // audio\n    mp3: Resource.LOAD_TYPE.AUDIO,\n    ogg: Resource.LOAD_TYPE.AUDIO,\n    wav: Resource.LOAD_TYPE.AUDIO,\n    // videos\n    mp4: Resource.LOAD_TYPE.VIDEO,\n    webm: Resource.LOAD_TYPE.VIDEO\n  };\n  Resource._xhrTypeMap = {\n    // xml\n    xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    // images\n    gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n    png: Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n    // json\n    json: Resource.XHR_RESPONSE_TYPE.JSON,\n    // text\n    text: Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt: Resource.XHR_RESPONSE_TYPE.TEXT,\n    // fonts\n    ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf: Resource.XHR_RESPONSE_TYPE.BUFFER\n  }; // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n\n  Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n  /**\n   * Quick helper to set a value on one of the extension maps. Ensures there is no\n   * dot at the start of the extension.\n   *\n   * @ignore\n   * @param {object} map - The map to set on.\n   * @param {string} extname - The extension (or key) to set.\n   * @param {number} val - The value to set.\n   */\n\n  function setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n      extname = extname.substring(1);\n    }\n\n    if (!extname) {\n      return;\n    }\n\n    map[extname] = val;\n  }\n  /**\n   * Quick helper to get string xhr type.\n   *\n   * @ignore\n   * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n   * @return {string} The type.\n   */\n\n\n  function reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n  } // Backwards compat\n\n\n  {\n    module.exports.default = Resource; // eslint-disable-line no-undef\n  }\n});\nunwrapExports(Resource_1);\nvar Resource_2 = Resource_1.Resource;\nvar b64 = createCommonjsModule(function (module, exports) {\n  exports.__esModule = true;\n  exports.encodeBinary = encodeBinary;\n  var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  /**\n   * Encodes binary into base64.\n   *\n   * @param {string} input The input data to encode.\n   * @returns {string} The encoded base64 string\n   */\n\n  function encodeBinary(input) {\n    var output = '';\n    var inx = 0;\n\n    while (inx < input.length) {\n      // Fill byte buffer array\n      var bytebuffer = [0, 0, 0];\n      var encodedCharIndexes = [0, 0, 0, 0];\n\n      for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n        if (inx < input.length) {\n          // throw away high-order byte, as documented at:\n          // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n          bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n        } else {\n          bytebuffer[jnx] = 0;\n        }\n      } // Get each encoded character, 6 bits at a time\n      // index 1: first 6 bits\n\n\n      encodedCharIndexes[0] = bytebuffer[0] >> 2; // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n\n      encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4; // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n\n      encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6; // index 3: forth 6 bits (6 least significant bits from input byte 3)\n\n      encodedCharIndexes[3] = bytebuffer[2] & 0x3f; // Determine whether padding happened, and adjust accordingly\n\n      var paddingBytes = inx - (input.length - 1);\n\n      switch (paddingBytes) {\n        case 2:\n          // Set last 2 characters to padding char\n          encodedCharIndexes[3] = 64;\n          encodedCharIndexes[2] = 64;\n          break;\n\n        case 1:\n          // Set last character to padding char\n          encodedCharIndexes[3] = 64;\n          break;\n\n        default:\n          break;\n        // No padding - proceed\n      } // Now we will grab each appropriate character out of our keystring\n      // based on our index array and append it to the output string\n\n\n      for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {\n        output += _keyStr.charAt(encodedCharIndexes[_jnx]);\n      }\n    }\n\n    return output;\n  } // Backwards compat\n\n\n  {\n    module.exports.default = encodeBinary; // eslint-disable-line no-undef\n  }\n});\nunwrapExports(b64);\nvar b64_1 = b64.encodeBinary;\nvar blob = createCommonjsModule(function (module, exports) {\n  exports.__esModule = true;\n  exports.blobMiddlewareFactory = blobMiddlewareFactory;\n  var Url = window.URL || window.webkitURL; // a middleware for transforming XHR loaded Blobs into more useful objects\n\n  function blobMiddlewareFactory() {\n    return function blobMiddleware(resource, next) {\n      if (!resource.data) {\n        next();\n        return;\n      } // if this was an XHR load of a blob\n\n\n      if (resource.xhr && resource.xhrType === Resource_1.Resource.XHR_RESPONSE_TYPE.BLOB) {\n        // if there is no blob support we probably got a binary string back\n        if (!window.Blob || typeof resource.data === 'string') {\n          var type = resource.xhr.getResponseHeader('content-type'); // this is an image, convert the binary string into a data url\n\n          if (type && type.indexOf('image') === 0) {\n            resource.data = new Image();\n            resource.data.src = 'data:' + type + ';base64,' + (0, b64.encodeBinary)(resource.xhr.responseText);\n            resource.type = Resource_1.Resource.TYPE.IMAGE; // wait until the image loads and then callback\n\n            resource.data.onload = function () {\n              resource.data.onload = null;\n              next();\n            }; // next will be called on load\n\n\n            return;\n          }\n        } // if content type says this is an image, then we should transform the blob into an Image object\n        else if (resource.data.type.indexOf('image') === 0) {\n            var src = Url.createObjectURL(resource.data);\n            resource.blob = resource.data;\n            resource.data = new Image();\n            resource.data.src = src;\n            resource.type = Resource_1.Resource.TYPE.IMAGE; // cleanup the no longer used blob after the image loads\n            // TODO: Is this correct? Will the image be invalid after revoking?\n\n            resource.data.onload = function () {\n              Url.revokeObjectURL(src);\n              resource.data.onload = null;\n              next();\n            }; // next will be called on load.\n\n\n            return;\n          }\n      }\n\n      next();\n    };\n  }\n});\nunwrapExports(blob);\nvar blob_1 = blob.blobMiddlewareFactory;\n/**\n * Loader plugin for handling Texture resources.\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\n\nvar TextureLoader = function TextureLoader() {};\n\nTextureLoader.use = function use(resource, next) {\n  // create a new texture if the data is an Image object\n  if (resource.data && resource.type === Resource.TYPE.IMAGE) {\n    resource.texture = Texture.fromLoader(resource.data, resource.url, resource.name);\n  }\n\n  next();\n};\n/**\n * The new loader, extends Resource Loader by Chad Engler: https://github.com/englercj/resource-loader\n *\n * ```js\n * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.\n * //or\n * const loader = new PIXI.Loader(); // you can also create your own if you want\n *\n * const sprites = {};\n *\n * // Chainable `add` to enqueue a resource\n * loader.add('bunny', 'data/bunny.png')\n *       .add('spaceship', 'assets/spritesheet.json');\n * loader.add('scoreFont', 'assets/score.fnt');\n *\n * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.\n * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).\n * loader.pre(cachingMiddleware);\n *\n * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.\n * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).\n * loader.use(parsingMiddleware);\n *\n * // The `load` method loads the queue of resources, and calls the passed in callback called once all\n * // resources have loaded.\n * loader.load((loader, resources) => {\n *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.\n *     // They have a couple default properties:\n *     // - `url`: The URL that the resource was loaded from\n *     // - `error`: The error that happened when trying to load (if any)\n *     // - `data`: The raw data that was loaded\n *     // also may contain other properties based on the middleware that runs.\n *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);\n *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);\n *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);\n * });\n *\n * // throughout the process multiple signals can be dispatched.\n * loader.onProgress.add(() => {}); // called once per loaded/errored file\n * loader.onError.add(() => {}); // called once per errored file\n * loader.onLoad.add(() => {}); // called once per loaded file\n * loader.onComplete.add(() => {}); // called once when the queued resources all load.\n * ```\n *\n * @see https://github.com/englercj/resource-loader\n *\n * @class Loader\n * @memberof PIXI\n * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n * @param {number} [concurrency=10] - The number of resources to load concurrently.\n */\n\n\nvar Loader =\n/*@__PURE__*/\nfunction (ResourceLoader) {\n  function Loader(baseUrl, concurrency) {\n    var this$1 = this;\n    ResourceLoader.call(this, baseUrl, concurrency);\n    EventEmitter.call(this);\n\n    for (var i = 0; i < Loader._plugins.length; ++i) {\n      var plugin = Loader._plugins[i];\n      var pre = plugin.pre;\n      var use = plugin.use;\n\n      if (pre) {\n        this.pre(pre);\n      }\n\n      if (use) {\n        this.use(use);\n      }\n    } // Compat layer, translate the new v2 signals into old v1 events.\n\n\n    this.onStart.add(function (l) {\n      return this$1.emit('start', l);\n    });\n    this.onProgress.add(function (l, r) {\n      return this$1.emit('progress', l, r);\n    });\n    this.onError.add(function (e, l, r) {\n      return this$1.emit('error', e, l, r);\n    });\n    this.onLoad.add(function (l, r) {\n      return this$1.emit('load', l, r);\n    });\n    this.onComplete.add(function (l, r) {\n      return this$1.emit('complete', l, r);\n    });\n    /**\n     * If this loader cannot be destroyed.\n     * @member {boolean}\n     * @default false\n     * @private\n     */\n\n    this._protected = false;\n  }\n\n  if (ResourceLoader) Loader.__proto__ = ResourceLoader;\n  Loader.prototype = Object.create(ResourceLoader && ResourceLoader.prototype);\n  Loader.prototype.constructor = Loader;\n  var staticAccessors = {\n    shared: {\n      configurable: true\n    }\n  };\n  /**\n   * Destroy the loader, removes references.\n   * @private\n   */\n\n  Loader.prototype.destroy = function destroy() {\n    if (!this._protected) {\n      this.removeAllListeners();\n      this.reset();\n    }\n  };\n  /**\n   * A premade instance of the loader that can be used to load resources.\n   * @name shared\n   * @type {PIXI.Loader}\n   * @static\n   * @memberof PIXI.Loader\n   */\n\n\n  staticAccessors.shared.get = function () {\n    var shared = Loader._shared;\n\n    if (!shared) {\n      shared = new Loader();\n      shared._protected = true;\n      Loader._shared = shared;\n    }\n\n    return shared;\n  };\n\n  Object.defineProperties(Loader, staticAccessors);\n  return Loader;\n}(ResourceLoader); // Copy EE3 prototype (mixin)\n\n\nObject.assign(Loader.prototype, EventEmitter.prototype);\n/**\n * Collection of all installed `use` middleware for Loader.\n *\n * @static\n * @member {Array<PIXI.ILoaderPlugin>} _plugins\n * @memberof PIXI.Loader\n * @private\n */\n\nLoader._plugins = [];\n/**\n * Adds a Loader plugin for the global shared loader and all\n * new Loader instances created.\n *\n * @static\n * @method registerPlugin\n * @memberof PIXI.Loader\n * @param {PIXI.ILoaderPlugin} plugin - The plugin to add\n * @return {PIXI.Loader} Reference to PIXI.Loader for chaining\n */\n\nLoader.registerPlugin = function registerPlugin(plugin) {\n  Loader._plugins.push(plugin);\n\n  if (plugin.add) {\n    plugin.add();\n  }\n\n  return Loader;\n}; // parse any blob into more usable objects (e.g. Image)\n\n\nLoader.registerPlugin({\n  use: blob_1()\n}); // parse any Image objects into textures\n\nLoader.registerPlugin(TextureLoader);\n/**\n * Plugin to be installed for handling specific Loader resources.\n *\n * @memberof PIXI\n * @typedef ILoaderPlugin\n * @property {function} [add] - Function to call immediate after registering plugin.\n * @property {PIXI.Loader.loaderMiddleware} [pre] - Middleware function to run before load, the\n *           arguments for this are `(resource, next)`\n * @property {PIXI.Loader.loaderMiddleware} [use] - Middleware function to run after load, the\n *           arguments for this are `(resource, next)`\n */\n\n/**\n * @memberof PIXI.Loader\n * @callback loaderMiddleware\n * @param {PIXI.LoaderResource} resource\n * @param {function} next\n */\n\n/**\n * @memberof PIXI.Loader#\n * @member {object} onStart\n */\n\n/**\n * @memberof PIXI.Loader#\n * @member {object} onProgress\n */\n\n/**\n * @memberof PIXI.Loader#\n * @member {object} onError\n */\n\n/**\n * @memberof PIXI.Loader#\n * @member {object} onLoad\n */\n\n/**\n * @memberof PIXI.Loader#\n * @member {object} onComplete\n */\n\n/**\n * Application plugin for supporting loader option. Installing the LoaderPlugin\n * is not necessary if using **pixi.js** or **pixi.js-legacy**.\n * @example\n * import {AppLoaderPlugin} from '@pixi/loaders';\n * import {Application} from '@pixi/app';\n * Application.registerPlugin(AppLoaderPlugin);\n * @class\n * @memberof PIXI\n */\n\nvar AppLoaderPlugin = function AppLoaderPlugin() {};\n\nAppLoaderPlugin.init = function init(options) {\n  options = Object.assign({\n    sharedLoader: false\n  }, options);\n  /**\n   * Loader instance to help with asset loading.\n   * @name PIXI.Application#loader\n   * @type {PIXI.Loader}\n   * @readonly\n   */\n\n  this.loader = options.sharedLoader ? Loader.shared : new Loader();\n};\n/**\n * Called when application destroyed\n * @private\n */\n\n\nAppLoaderPlugin.destroy = function destroy() {\n  if (this.loader) {\n    this.loader.destroy();\n    this.loader = null;\n  }\n};\n/**\n * Reference to **{@link https://github.com/englercj/resource-loader\n * resource-loader}**'s Resource class.\n * @see http://englercj.github.io/resource-loader/Resource.html\n * @class LoaderResource\n * @memberof PIXI\n */\n\n\nvar LoaderResource = Resource;\nexport { AppLoaderPlugin, Loader, LoaderResource, TextureLoader };","map":null,"metadata":{},"sourceType":"module"}