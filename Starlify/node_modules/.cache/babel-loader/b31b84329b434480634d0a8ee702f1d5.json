{"ast":null,"code":"/*!\n * @pixi/canvas-sprite - v5.0.4\n * Compiled Fri, 07 Jun 2019 17:17:49 UTC\n *\n * @pixi/canvas-sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, GroupD8 } from '@pixi/math';\nimport { CanvasTinter } from '@pixi/canvas-renderer';\nimport { Sprite } from '@pixi/sprite';\nvar canvasRenderWorldTransform = new Matrix();\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasSpriteRenderer = function CanvasSpriteRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders the sprite object.\n *\n * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n */\n\n\nCanvasSpriteRenderer.prototype.render = function render(sprite) {\n  var texture = sprite._texture;\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var width = texture._frame.width;\n  var height = texture._frame.height;\n  var wt = sprite.transform.worldTransform;\n  var dx = 0;\n  var dy = 0;\n  var source = texture.baseTexture.getDrawableSource();\n\n  if (texture.orig.width <= 0 || texture.orig.height <= 0 || !source) {\n    return;\n  }\n\n  if (!texture.valid) {\n    return;\n  }\n\n  renderer.setBlendMode(sprite.blendMode, true);\n  renderer.context.globalAlpha = sprite.worldAlpha; // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n\n  var smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n  if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {\n    context[renderer.smoothProperty] = smoothingEnabled;\n  }\n\n  if (texture.trim) {\n    dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;\n    dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;\n  } else {\n    dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n    dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n  }\n\n  if (texture.rotate) {\n    wt.copyTo(canvasRenderWorldTransform);\n    wt = canvasRenderWorldTransform;\n    GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy); // the anchor has already been applied above, so lets set it to zero\n\n    dx = 0;\n    dy = 0;\n  }\n\n  dx -= width / 2;\n  dy -= height / 2; // Allow for pixel rounding\n\n  if (sprite.roundPixels) {\n    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);\n    dx = dx | 0;\n    dy = dy | 0;\n  } else {\n    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n  }\n\n  var resolution = texture.baseTexture.resolution;\n  var outerBlend = renderer._outerBlend;\n\n  if (outerBlend) {\n    context.save();\n    context.beginPath();\n    context.rect(dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n    context.clip();\n  }\n\n  if (sprite.tint !== 0xFFFFFF) {\n    if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {\n      sprite._cachedTint = sprite.tint; // TODO clean up caching - how to clean up the caches?\n\n      sprite._tintedCanvas = CanvasTinter.getTintedCanvas(sprite, sprite.tint);\n    }\n\n    context.drawImage(sprite._tintedCanvas, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n  } else {\n    context.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n  }\n\n  if (outerBlend) {\n    context.restore();\n  } // just in case, leaking outer blend here will be catastrophic!\n\n\n  renderer.setBlendMode(BLEND_MODES.NORMAL);\n};\n/**\n * destroy the sprite object.\n *\n */\n\n\nCanvasSpriteRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\n\n\nSprite.prototype._tintedCanvas = null;\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\n\nSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n  renderer.plugins.sprite.render(this);\n};\n\nexport { CanvasSpriteRenderer };","map":null,"metadata":{},"sourceType":"module"}