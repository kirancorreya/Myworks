{"ast":null,"code":"const LoopMode = {\n  once: THREE.LoopOnce,\n  repeat: THREE.LoopRepeat,\n  pingpong: THREE.LoopPingPong\n};\n/**\n * animation-mixer\n *\n * Player for animation clips. Intended to be compatible with any model format that supports\n * skeletal or morph animations through THREE.AnimationMixer.\n * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer\n */\n\nmodule.exports = AFRAME.registerComponent('animation-mixer', {\n  schema: {\n    clip: {\n      default: '*'\n    },\n    duration: {\n      default: 0\n    },\n    clampWhenFinished: {\n      default: false,\n      type: 'boolean'\n    },\n    crossFadeDuration: {\n      default: 0\n    },\n    loop: {\n      default: 'repeat',\n      oneOf: Object.keys(LoopMode)\n    },\n    repetitions: {\n      default: Infinity,\n      min: 0\n    },\n    timeScale: {\n      default: 1\n    }\n  },\n  init: function () {\n    /** @type {THREE.Mesh} */\n    this.model = null;\n    /** @type {THREE.AnimationMixer} */\n\n    this.mixer = null;\n    /** @type {Array<THREE.AnimationAction>} */\n\n    this.activeActions = [];\n    const model = this.el.getObject3D('mesh');\n\n    if (model) {\n      this.load(model);\n    } else {\n      this.el.addEventListener('model-loaded', e => {\n        this.load(e.detail.model);\n      });\n    }\n  },\n  load: function (model) {\n    const el = this.el;\n    this.model = model;\n    this.mixer = new THREE.AnimationMixer(model);\n    this.mixer.addEventListener('loop', e => {\n      el.emit('animation-loop', {\n        action: e.action,\n        loopDelta: e.loopDelta\n      });\n    });\n    this.mixer.addEventListener('finished', e => {\n      el.emit('animation-finished', {\n        action: e.action,\n        direction: e.direction\n      });\n    });\n    if (this.data.clip) this.update({});\n  },\n  remove: function () {\n    if (this.mixer) this.mixer.stopAllAction();\n  },\n  update: function (prevData) {\n    if (!prevData) return;\n    const data = this.data;\n    const changes = AFRAME.utils.diff(data, prevData); // If selected clips have changed, restart animation.\n\n    if ('clip' in changes) {\n      this.stopAction();\n      if (data.clip) this.playAction();\n      return;\n    } // Otherwise, modify running actions.\n\n\n    this.activeActions.forEach(action => {\n      if ('duration' in changes && data.duration) {\n        action.setDuration(data.duration);\n      }\n\n      if ('clampWhenFinished' in changes) {\n        action.clampWhenFinished = data.clampWhenFinished;\n      }\n\n      if ('loop' in changes || 'repetitions' in changes) {\n        action.setLoop(LoopMode[data.loop], data.repetitions);\n      }\n\n      if ('timeScale' in changes) {\n        action.setEffectiveTimeScale(data.timeScale);\n      }\n    });\n  },\n  stopAction: function () {\n    const data = this.data;\n\n    for (let i = 0; i < this.activeActions.length; i++) {\n      data.crossFadeDuration ? this.activeActions[i].fadeOut(data.crossFadeDuration) : this.activeActions[i].stop();\n    }\n\n    this.activeActions.length = 0;\n  },\n  playAction: function () {\n    if (!this.mixer) return;\n    const model = this.model,\n          data = this.data,\n          clips = model.animations || (model.geometry || {}).animations || [];\n    if (!clips.length) return;\n    const re = wildcardToRegExp(data.clip);\n\n    for (let clip, i = 0; clip = clips[i]; i++) {\n      if (clip.name.match(re)) {\n        const action = this.mixer.clipAction(clip, model);\n        action.enabled = true;\n        action.clampWhenFinished = data.clampWhenFinished;\n        if (data.duration) action.setDuration(data.duration);\n        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);\n        action.setLoop(LoopMode[data.loop], data.repetitions).fadeIn(data.crossFadeDuration).play();\n        this.activeActions.push(action);\n      }\n    }\n  },\n  tick: function (t, dt) {\n    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);\n  }\n});\n/**\n * Creates a RegExp from the given string, converting asterisks to .* expressions,\n * and escaping all other characters.\n */\n\nfunction wildcardToRegExp(s) {\n  return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n}\n/**\n * RegExp-escapes all characters in the given string.\n */\n\n\nfunction regExpEscape(s) {\n  return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}","map":null,"metadata":{},"sourceType":"script"}