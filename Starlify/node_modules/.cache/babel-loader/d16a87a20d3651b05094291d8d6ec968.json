{"ast":null,"code":"import { Mesh, MeshLambertMaterial, BufferGeometry, BufferAttribute, Matrix4, Vector3, SphereBufferGeometry, CylinderBufferGeometry, ConeBufferGeometry, Line, LineBasicMaterial, QuadraticBezierCurve3, CubicBezierCurve3, Group } from 'three';\nimport { forceSimulation, forceLink, forceManyBody, forceCenter, forceRadial } from 'd3-force-3d';\nimport graph from 'ngraph.graph';\nimport forcelayout from 'ngraph.forcelayout';\nimport forcelayout3d from 'ngraph.forcelayout3d';\nimport Kapsule from 'kapsule';\nimport accessorFn from 'accessor-fn';\nimport { scaleOrdinal } from 'd3-scale';\nimport { schemePaired } from 'd3-scale-chromatic';\nimport tinyColor from 'tinycolor2';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar colorStr2Hex = function colorStr2Hex(str) {\n  return isNaN(str) ? parseInt(tinyColor(str).toHex(), 16) : str;\n};\n\nvar colorAlpha = function colorAlpha(str) {\n  return isNaN(str) ? tinyColor(str).getAlpha() : 1;\n};\n\nvar autoColorScale = scaleOrdinal(schemePaired); // Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\n\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths(_ref, idAccessor) {\n  var nodes = _ref.nodes,\n      links = _ref.links; // linked graph\n\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1\n    };\n  });\n  links.forEach(function (_ref2) {\n    var source = _ref2.source,\n        target = _ref2.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  traverse(Object.values(graph)); // cleanup\n\n  Object.keys(graph).forEach(function (id) {\n    return graph[id] = graph[id].depth;\n  });\n  return graph;\n\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = nodeStack.length;\n\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        throw \"Invalid DAG structure! Found cycle in node path: \".concat(loop.join(' -> '), \".\");\n      }\n\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]));\n      }\n    }\n  }\n}\n\nvar three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Mesh: Mesh,\n  MeshLambertMaterial: MeshLambertMaterial,\n  BufferGeometry: BufferGeometry,\n  BufferAttribute: BufferAttribute,\n  Matrix4: Matrix4,\n  Vector3: Vector3,\n  SphereBufferGeometry: SphereBufferGeometry,\n  CylinderBufferGeometry: CylinderBufferGeometry,\n  ConeBufferGeometry: ConeBufferGeometry,\n  Line: Line,\n  LineBasicMaterial: LineBasicMaterial,\n  QuadraticBezierCurve3: QuadraticBezierCurve3,\n  CubicBezierCurve3: CubicBezierCurve3\n};\nvar ngraph = {\n  graph: graph,\n  forcelayout: forcelayout,\n  forcelayout3d: forcelayout3d\n};\nvar DAG_LEVEL_NODE_RATIO = 2;\nvar ForceGraph = Kapsule({\n  props: {\n    jsonUrl: {\n      onChange: function onChange(jsonUrl, state) {\n        var _this = this;\n\n        if (jsonUrl && !state.fetchingJson) {\n          // Load data asynchronously\n          state.fetchingJson = true;\n          state.onLoading();\n          fetch(jsonUrl).then(function (r) {\n            return r.json();\n          }).then(function (json) {\n            state.fetchingJson = false;\n\n            _this.graphData(json);\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(graphData, state) {\n        if (graphData.nodes.length || graphData.links.length) {\n          console.info('force-graph loading', graphData.nodes.length + ' nodes', graphData.links.length + ' links');\n        }\n\n        state.engineRunning = false; // Pause simulation immediately\n\n        state.sceneNeedsRepopulating = true;\n        state.simulationNeedsReheating = true;\n      }\n    },\n    numDimensions: {\n      \"default\": 3,\n      onChange: function onChange(numDim, state) {\n        state.simulationNeedsReheating = true;\n        var chargeForce = state.d3ForceLayout.force('charge'); // Increase repulsion on 3D mode for improved spatial separation\n\n        if (chargeForce) {\n          chargeForce.strength(numDim > 2 ? -60 : -30);\n        }\n\n        if (numDim < 3) {\n          eraseDimension(state.graphData.nodes, 'z');\n        }\n\n        if (numDim < 2) {\n          eraseDimension(state.graphData.nodes, 'y');\n        }\n\n        function eraseDimension(nodes, dim) {\n          nodes.forEach(function (d) {\n            delete d[dim]; // position\n\n            delete d[\"v\".concat(dim)]; // velocity\n          });\n        }\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, zin, zout, radialin, radialout\n        !dagMode && state.forceEngine === 'd3' && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = n.fz = undefined;\n        }); // unfix nodes when disabling dag mode\n\n        state.simulationNeedsReheating = true;\n      }\n    },\n    dagLevelDistance: {\n      onChange: function onChange(_, state) {\n        state.simulationNeedsReheating = true;\n      }\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // volume per val unit\n    nodeId: {\n      \"default\": 'id',\n      onChange: function onChange(_, state) {\n        state.simulationNeedsReheating = true;\n      }\n    },\n    nodeVal: {\n      \"default\": 'val',\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    nodeResolution: {\n      \"default\": 8,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // how many slice segments in the sphere's circumference\n    nodeColor: {\n      \"default\": 'color',\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    nodeAutoColorBy: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    nodeOpacity: {\n      \"default\": 0.75,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    nodeThreeObject: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    nodeThreeObjectExtend: {\n      \"default\": false,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkSource: {\n      \"default\": 'source',\n      onChange: function onChange(_, state) {\n        state.simulationNeedsReheating = true;\n      }\n    },\n    linkTarget: {\n      \"default\": 'target',\n      onChange: function onChange(_, state) {\n        state.simulationNeedsReheating = true;\n      }\n    },\n    linkVisibility: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkColor: {\n      \"default\": 'color',\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkAutoColorBy: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkOpacity: {\n      \"default\": 0.2,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkWidth: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.\n    linkResolution: {\n      \"default\": 6,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // how many radial segments in each line tube's geometry\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curvature radius (0: straight, 1: semi-circle)\n    linkCurveRotation: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)\n    linkMaterial: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkThreeObject: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkThreeObjectExtend: {\n      \"default\": false,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkPositionUpdate: {\n      triggerUpdate: false\n    },\n    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkDirectionalArrowColor: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      \"default\": 8,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      \"default\": 0,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 0.5,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkDirectionalParticleColor: {\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    linkDirectionalParticleResolution: {\n      \"default\": 4,\n      onChange: function onChange(_, state) {\n        state.sceneNeedsRepopulating = true;\n      }\n    },\n    // how many slice segments in the particle sphere's circumference\n    forceEngine: {\n      \"default\": 'd3',\n      onChange: function onChange(_, state) {\n        state.simulationNeedsReheating = true;\n      }\n    },\n    // d3 or ngraph\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.d3ForceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.d3ForceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.d3ForceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    refresh: function refresh(state) {\n      state.sceneNeedsRepopulating = true;\n      state.simulationNeedsReheating = true;\n\n      state._rerender();\n\n      return this;\n    },\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.d3ForceLayout.force(forceName); // Force getter\n      }\n\n      state.d3ForceLayout.force(forceName, forceFn); // Force setter\n\n      return this;\n    },\n    _updateScene: function _updateScene(state) {},\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    tickFrame: function tickFrame(state) {\n      var isD3Sim = state.forceEngine !== 'ngraph';\n\n      if (state.engineRunning) {\n        layoutTick();\n      }\n\n      updateArrows();\n      updatePhotons();\n      return this; //\n\n      function layoutTick() {\n        if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime) {\n          state.engineRunning = false; // Stop ticking graph\n\n          state.onEngineStop();\n        } else {\n          state.layout[isD3Sim ? 'tick' : 'step'](); // Tick it\n\n          state.onEngineTick();\n        } // Update nodes position\n\n\n        state.graphData.nodes.forEach(function (node) {\n          var obj = node.__threeObj;\n          if (!obj) return;\n          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);\n          obj.position.x = pos.x;\n          obj.position.y = pos.y || 0;\n          obj.position.z = pos.z || 0;\n        }); // Update links position\n\n        var linkCurvatureAccessor = accessorFn(state.linkCurvature);\n        var linkCurveRotationAccessor = accessorFn(state.linkCurveRotation);\n        var linkThreeObjectExtendAccessor = accessorFn(state.linkThreeObjectExtend);\n        state.graphData.links.forEach(function (link) {\n          var line = link.__lineObj;\n          if (!line) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          calcLinkCurve(link); // calculate link curve for all links, including custom replaced, so it can be used in directional functionality\n\n          var extendedObj = linkThreeObjectExtendAccessor(link);\n\n          if (state.linkPositionUpdate && state.linkPositionUpdate(extendedObj ? line.children[0] : line, // pass child custom object if extending the default\n          {\n            start: {\n              x: start.x,\n              y: start.y,\n              z: start.z\n            },\n            end: {\n              x: end.x,\n              y: end.y,\n              z: end.z\n            }\n          }, link) && !extendedObj) {\n            // exit if successfully custom updated position of non-extended obj\n            return;\n          }\n\n          if (line.type === 'Line') {\n            // Update line geometry\n            var curveResolution = 30; // # line segments\n\n            var curve = link.__curve;\n\n            if (!curve) {\n              // straight line\n              var linePos = line.geometry.getAttribute('position');\n\n              if (!linePos || !linePos.array || linePos.array.length !== 6) {\n                line.geometry.addAttribute('position', linePos = new three.BufferAttribute(new Float32Array(2 * 3), 3));\n              }\n\n              linePos.array[0] = start.x;\n              linePos.array[1] = start.y || 0;\n              linePos.array[2] = start.z || 0;\n              linePos.array[3] = end.x;\n              linePos.array[4] = end.y || 0;\n              linePos.array[5] = end.z || 0;\n              linePos.needsUpdate = true;\n            } else {\n              // bezier curve line\n              line.geometry.setFromPoints(curve.getPoints(curveResolution));\n            }\n\n            line.geometry.computeBoundingSphere();\n          } else if (line.type === 'Mesh') {\n            // Update cylinder geometry\n            // links with width ignore linkCurvature because TubeGeometries can't be updated\n            link.__curve = null; // force reset link curve\n\n            var vStart = new three.Vector3(start.x, start.y || 0, start.z || 0);\n            var vEnd = new three.Vector3(end.x, end.y || 0, end.z || 0);\n            var distance = vStart.distanceTo(vEnd);\n            line.position.x = vStart.x;\n            line.position.y = vStart.y;\n            line.position.z = vStart.z;\n            line.scale.z = distance;\n            line.parent.localToWorld(vEnd); // lookAt requires world coords\n\n            line.lookAt(vEnd);\n          }\n        }); //\n\n        function calcLinkCurve(link) {\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var curvature = linkCurvatureAccessor(link);\n\n          if (!curvature) {\n            link.__curve = null; // Straight line\n          } else {\n            // bezier curve line (only for line types)\n            var vStart = new three.Vector3(start.x, start.y || 0, start.z || 0);\n            var vEnd = new three.Vector3(end.x, end.y || 0, end.z || 0);\n            var l = vStart.distanceTo(vEnd); // line length\n\n            var curve;\n            var curveRotation = linkCurveRotationAccessor(link);\n\n            if (l > 0) {\n              var dx = end.x - start.x;\n              var dy = end.y - start.y || 0;\n              var vLine = new three.Vector3().subVectors(vEnd, vStart);\n              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three.Vector3(0, 0, 1) : new three.Vector3(0, 1, 0)) // avoid cross-product of parallel vectors (prefer Z, fallback to Y)\n              .applyAxisAngle(vLine.normalize(), curveRotation) // rotate along line axis according to linkCurveRotation\n              .add(new three.Vector3().addVectors(vStart, vEnd).divideScalar(2));\n              curve = new three.QuadraticBezierCurve3(vStart, cp, vEnd);\n            } else {\n              // Same point, draw a loop\n              var d = curvature * 70;\n              var endAngle = -curveRotation; // Rotate clockwise (from Z angle perspective)\n\n              var startAngle = endAngle + Math.PI / 2;\n              curve = new three.CubicBezierCurve3(vStart, new three.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);\n            }\n\n            link.__curve = curve;\n          }\n        }\n      }\n\n      function updateArrows() {\n        // update link arrow position\n        var arrowRelPosAccessor = accessorFn(state.linkDirectionalArrowRelPos);\n        var arrowLengthAccessor = accessorFn(state.linkDirectionalArrowLength);\n        var nodeValAccessor = accessorFn(state.nodeVal);\n        state.graphData.links.forEach(function (link) {\n          var arrowObj = link.__arrowObj;\n          if (!arrowObj) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;\n          var arrowLength = arrowLengthAccessor(link);\n          var arrowRelPos = arrowRelPosAccessor(link);\n          var getPosAlongLine = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(['x', 'y', 'z'].map(function (dim) {\n            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);\n          }).reduce(function (acc, v) {\n            return acc + v;\n          }, 0));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getPosAlongLine(posAlongLine / lineLen);\n          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);\n          ['x', 'y', 'z'].forEach(function (dim) {\n            return arrowObj.position[dim] = arrowTail[dim];\n          });\n\n          var headVec = _construct(three.Vector3, _toConsumableArray(['x', 'y', 'z'].map(function (c) {\n            return arrowHead[c];\n          })));\n\n          arrowObj.parent.localToWorld(headVec); // lookAt requires world coords\n\n          arrowObj.lookAt(headVec);\n        });\n      }\n\n      function updatePhotons() {\n        // update link particle positions\n        var particleSpeedAccessor = accessorFn(state.linkDirectionalParticleSpeed);\n        state.graphData.links.forEach(function (link) {\n          var photons = link.__photonObjs;\n          if (!photons || !photons.length) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = particleSpeedAccessor(link);\n          var getPhotonPos = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          photons.forEach(function (photon, idx) {\n            var photonPosRatio = photon.__progressRatio = ((photon.__progressRatio || idx / photons.length) + particleSpeed) % 1;\n            var pos = getPhotonPos(photonPosRatio);\n            ['x', 'y', 'z'].forEach(function (dim) {\n              return photon.position[dim] = pos[dim];\n            });\n          });\n        });\n      }\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      d3ForceLayout: forceSimulation().force('link', forceLink()).force('charge', forceManyBody()).force('center', forceCenter()).force('dagRadial', null).stop(),\n      engineRunning: false,\n      sceneNeedsRepopulating: true,\n      simulationNeedsReheating: true\n    };\n  },\n  init: function init(threeObj, state) {\n    // Main three object to manipulate\n    state.graphScene = threeObj;\n  },\n  update: function update(state) {\n    state.engineRunning = false; // pause simulation\n\n    if (state.sceneNeedsRepopulating) {\n      state.sceneNeedsRepopulating = false;\n\n      if (state.nodeAutoColorBy !== null) {\n        // Auto add color to uncolored nodes\n        autoColorObjects(state.graphData.nodes, accessorFn(state.nodeAutoColorBy), state.nodeColor);\n      }\n\n      if (state.linkAutoColorBy !== null) {\n        // Auto add color to uncolored links\n        autoColorObjects(state.graphData.links, accessorFn(state.linkAutoColorBy), state.linkColor);\n      } // Clear the scene\n\n\n      var materialDispose = function materialDispose(material) {\n        if (material instanceof Array) {\n          material.forEach(materialDispose);\n        } else {\n          if (material.map) {\n            material.map.dispose();\n          }\n\n          material.dispose();\n        }\n      };\n\n      var deallocate = function deallocate(obj) {\n        if (obj.geometry) {\n          obj.geometry.dispose();\n        }\n\n        if (obj.material) {\n          materialDispose(obj.material);\n        }\n\n        if (obj.texture) {\n          obj.texture.dispose();\n        }\n\n        if (obj.children) {\n          obj.children.forEach(deallocate);\n        }\n      };\n\n      while (state.graphScene.children.length) {\n        var obj = state.graphScene.children[0];\n        state.graphScene.remove(obj);\n        deallocate(obj);\n      } // Add WebGL objects\n\n\n      var customNodeObjectAccessor = accessorFn(state.nodeThreeObject);\n      var customNodeObjectExtendAccessor = accessorFn(state.nodeThreeObjectExtend);\n      var valAccessor = accessorFn(state.nodeVal);\n      var colorAccessor = accessorFn(state.nodeColor);\n      var sphereGeometries = {}; // indexed by node value\n\n      var sphereMaterials = {}; // indexed by color\n\n      state.graphData.nodes.forEach(function (node) {\n        var customObj = customNodeObjectAccessor(node);\n        var extendObj = customNodeObjectExtendAccessor(node);\n\n        if (customObj && state.nodeThreeObject === customObj) {\n          // clone object if it's a shared object among all nodes\n          customObj = customObj.clone();\n        }\n\n        var obj;\n\n        if (customObj && !extendObj) {\n          obj = customObj;\n        } else {\n          // Add default object (sphere mesh)\n          var val = valAccessor(node) || 1;\n\n          if (!sphereGeometries.hasOwnProperty(val)) {\n            sphereGeometries[val] = new three.SphereBufferGeometry(Math.cbrt(val) * state.nodeRelSize, state.nodeResolution, state.nodeResolution);\n          }\n\n          var color = colorAccessor(node);\n\n          if (!sphereMaterials.hasOwnProperty(color)) {\n            sphereMaterials[color] = new three.MeshLambertMaterial({\n              color: colorStr2Hex(color || '#ffffaa'),\n              transparent: true,\n              opacity: state.nodeOpacity * colorAlpha(color)\n            });\n          }\n\n          obj = new three.Mesh(sphereGeometries[val], sphereMaterials[color]);\n\n          if (customObj && extendObj) {\n            obj.add(customObj); // extend default with custom\n          }\n        }\n\n        obj.__graphObjType = 'node'; // Add object type\n\n        obj.__data = node; // Attach node data\n\n        state.graphScene.add(node.__threeObj = obj);\n      });\n      var customLinkObjectAccessor = accessorFn(state.linkThreeObject);\n      var customLinkObjectExtendAccessor = accessorFn(state.linkThreeObjectExtend);\n      var customLinkMaterialAccessor = accessorFn(state.linkMaterial);\n      var linkVisibilityAccessor = accessorFn(state.linkVisibility);\n      var linkColorAccessor = accessorFn(state.linkColor);\n      var linkWidthAccessor = accessorFn(state.linkWidth);\n      var linkArrowLengthAccessor = accessorFn(state.linkDirectionalArrowLength);\n      var linkArrowColorAccessor = accessorFn(state.linkDirectionalArrowColor);\n      var linkParticlesAccessor = accessorFn(state.linkDirectionalParticles);\n      var linkParticleWidthAccessor = accessorFn(state.linkDirectionalParticleWidth);\n      var linkParticleColorAccessor = accessorFn(state.linkDirectionalParticleColor);\n      var lineMaterials = {}; // indexed by link color\n\n      var cylinderGeometries = {}; // indexed by link width\n\n      var particleMaterials = {}; // indexed by link color\n\n      var particleGeometries = {}; // indexed by particle width\n\n      state.graphData.links.forEach(function (link) {\n        if (!linkVisibilityAccessor(link)) {\n          // Exclude non-visible links\n          link.__lineObj = link.__arrowObj = link.__photonObjs = null;\n          return;\n        }\n\n        var color = linkColorAccessor(link);\n        var customObj = customLinkObjectAccessor(link);\n        var extendObj = customLinkObjectExtendAccessor(link);\n\n        if (customObj && state.linkThreeObject === customObj) {\n          // clone object if it's a shared object among all links\n          customObj = customObj.clone();\n        }\n\n        var lineObj;\n\n        if (customObj && !extendObj) {\n          lineObj = customObj;\n        } else {\n          // Add default line object\n          var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n          var useCylinder = !!linkWidth;\n          var geometry;\n\n          if (useCylinder) {\n            if (!cylinderGeometries.hasOwnProperty(linkWidth)) {\n              var r = linkWidth / 2;\n              geometry = new three.CylinderBufferGeometry(r, r, 1, state.linkResolution, 1, false);\n              geometry.applyMatrix(new three.Matrix4().makeTranslation(0, 1 / 2, 0));\n              geometry.applyMatrix(new three.Matrix4().makeRotationX(Math.PI / 2));\n              cylinderGeometries[linkWidth] = geometry;\n            }\n\n            geometry = cylinderGeometries[linkWidth];\n          } else {\n            // Use plain line (constant width)\n            geometry = new three.BufferGeometry();\n            geometry.addAttribute('position', new three.BufferAttribute(new Float32Array(2 * 3), 3));\n          }\n\n          var lineMaterial = customLinkMaterialAccessor(link);\n\n          if (!lineMaterial) {\n            if (!lineMaterials.hasOwnProperty(color)) {\n              var lineOpacity = state.linkOpacity * colorAlpha(color);\n              lineMaterials[color] = new three.MeshLambertMaterial({\n                color: colorStr2Hex(color || '#f0f0f0'),\n                transparent: lineOpacity < 1,\n                opacity: lineOpacity,\n                depthWrite: lineOpacity >= 1 // Prevent transparency issues\n\n              });\n            }\n\n            lineMaterial = lineMaterials[color];\n          }\n\n          lineObj = new three[useCylinder ? 'Mesh' : 'Line'](geometry, lineMaterial);\n\n          if (customObj && extendObj) {\n            lineObj.add(customObj); // extend default with custom\n          }\n        }\n\n        lineObj.renderOrder = 10; // Prevent visual glitches of dark lines on top of nodes by rendering them last\n\n        lineObj.__graphObjType = 'link'; // Add object type\n\n        lineObj.__data = link; // Attach link data\n\n        state.graphScene.add(link.__lineObj = lineObj); // Add arrow\n\n        var arrowLength = linkArrowLengthAccessor(link);\n\n        if (arrowLength && arrowLength > 0) {\n          var arrowColor = linkArrowColorAccessor(link) || color || '#f0f0f0';\n          var coneGeometry = new three.ConeBufferGeometry(arrowLength * 0.25, arrowLength, state.linkDirectionalArrowResolution); // Correct orientation\n\n          coneGeometry.translate(0, arrowLength / 2, 0);\n          coneGeometry.rotateX(Math.PI / 2);\n          var arrowObj = new three.Mesh(coneGeometry, new three.MeshLambertMaterial({\n            color: colorStr2Hex(arrowColor),\n            transparent: true,\n            opacity: state.linkOpacity * 3\n          }));\n          state.graphScene.add(link.__arrowObj = arrowObj);\n        } // Add photon particles\n\n\n        var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n        var photonR = Math.ceil(linkParticleWidthAccessor(link) * 10) / 10 / 2;\n        var photonColor = linkParticleColorAccessor(link) || color || '#f0f0f0';\n\n        if (!particleGeometries.hasOwnProperty(photonR)) {\n          particleGeometries[photonR] = new three.SphereBufferGeometry(photonR, state.linkDirectionalParticleResolution, state.linkDirectionalParticleResolution);\n        }\n\n        var particleGeometry = particleGeometries[photonR];\n\n        if (!particleMaterials.hasOwnProperty(photonColor)) {\n          particleMaterials[photonColor] = new three.MeshLambertMaterial({\n            color: colorStr2Hex(photonColor),\n            transparent: true,\n            opacity: state.linkOpacity * 3\n          });\n        }\n\n        var particleMaterial = particleMaterials[photonColor];\n\n        var photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return new three.Mesh(particleGeometry, particleMaterial);\n        });\n\n        photons.forEach(function (photon) {\n          return state.graphScene.add(photon);\n        });\n        link.__photonObjs = photons;\n      });\n    }\n\n    if (state.simulationNeedsReheating) {\n      state.simulationNeedsReheating = false;\n      state.engineRunning = false; // Pause simulation\n      // parse links\n\n      state.graphData.links.forEach(function (link) {\n        link.source = link[state.linkSource];\n        link.target = link[state.linkTarget];\n      }); // Feed data to force-directed layout\n\n      var isD3Sim = state.forceEngine !== 'ngraph';\n      var layout;\n\n      if (isD3Sim) {\n        // D3-force\n        (layout = state.d3ForceLayout).stop().alpha(1) // re-heat the simulation\n        .numDimensions(state.numDimensions).nodes(state.graphData.nodes); // add links (if link force is still active)\n\n        var linkForce = state.d3ForceLayout.force('link');\n\n        if (linkForce) {\n          linkForce.id(function (d) {\n            return d[state.nodeId];\n          }).links(state.graphData.links);\n        } // setup dag force constraints\n\n\n        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n          return node[state.nodeId];\n        });\n        var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1); // Fix nodes to x,y,z for dag mode\n\n        if (state.dagMode) {\n          var getFFn = function getFFn(fix, invert) {\n            return function (node) {\n              return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n            };\n          };\n\n          var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');\n          var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'td');\n          var fzFn = getFFn(['zin', 'zout'].indexOf(state.dagMode) !== -1, state.dagMode === 'zout');\n          state.graphData.nodes.forEach(function (node) {\n            node.fx = fxFn(node);\n            node.fy = fyFn(node);\n            node.fz = fzFn(node);\n          });\n        }\n\n        state.d3ForceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? forceRadial(function (node) {\n          var nodeDepth = nodeDepths[node[state.nodeId]];\n          return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n        }).strength(1) : null);\n      } else {\n        // ngraph\n        var _graph = ngraph.graph();\n\n        state.graphData.nodes.forEach(function (node) {\n          _graph.addNode(node[state.nodeId]);\n        });\n        state.graphData.links.forEach(function (link) {\n          _graph.addLink(link.source, link.target);\n        });\n        layout = ngraph['forcelayout' + (state.numDimensions === 2 ? '' : '3d')](_graph);\n        layout.graph = _graph; // Attach graph reference to layout\n      }\n\n      for (var i = 0; i < state.warmupTicks; i++) {\n        layout[isD3Sim ? 'tick' : 'step']();\n      } // Initial ticks before starting to render\n\n\n      state.layout = layout;\n      this.resetCountdown();\n      state.onFinishLoading();\n    }\n\n    state.engineRunning = true; // resume simulation\n  }\n});\n\nfunction fromKapsule(kapsule) {\n  var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;\n  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var FromKapsule =\n  /*#__PURE__*/\n  function (_baseClass) {\n    _inherits(FromKapsule, _baseClass);\n\n    function FromKapsule() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, FromKapsule);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FromKapsule)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      _this.__kapsuleInstance = kapsule().apply(void 0, [].concat(_toConsumableArray(initKapsuleWithSelf ? [_assertThisInitialized(_this)] : []), args));\n      return _this;\n    }\n\n    return FromKapsule;\n  }(baseClass); // attach kapsule props/methods to class prototype\n\n\n  Object.keys(kapsule()).forEach(function (m) {\n    return FromKapsule.prototype[m] = function () {\n      var _this$__kapsuleInstan;\n\n      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);\n\n      return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj\n      : returnVal;\n    };\n  });\n  return FromKapsule;\n}\n\nvar three$1 = window.THREE ? window.THREE : {\n  Group: Group\n}; // Prefer consumption from global THREE, if exists\n\nvar threeForcegraph = fromKapsule(ForceGraph, three$1.Group, true);\nexport default threeForcegraph;","map":null,"metadata":{},"sourceType":"module"}