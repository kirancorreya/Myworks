{"ast":null,"code":"/* global AFRAME */\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nvar accessorFn = require('accessor-fn');\n\nvar ThreeForceGraph = require('three-forcegraph');\n\nif (ThreeForceGraph.hasOwnProperty('default')) {\n  // unwrap default export\n  ThreeForceGraph = ThreeForceGraph.default;\n}\n\nvar parseFn = function (prop) {\n  var geval = eval; // Avoid using eval directly https://github.com/rollup/rollup/wiki/Troubleshooting#avoiding-eval\n\n  try {\n    var evalled = geval('(' + prop + ')');\n    return evalled;\n  } catch (e) {} // Can't eval, not a function\n\n\n  return null;\n};\n\nvar parseAccessor = function (prop) {\n  if (!isNaN(parseFloat(prop))) {\n    return parseFloat(prop);\n  } // parse numbers\n\n\n  if (parseFn(prop)) {\n    return parseFn(prop);\n  } // parse functions\n\n\n  return prop; //strings\n};\n/**\n * 3D Force-Directed Graph component for A-Frame.\n */\n\n\nAFRAME.registerComponent('forcegraph', {\n  schema: {\n    jsonUrl: {\n      type: 'string',\n      default: ''\n    },\n    nodes: {\n      parse: JSON.parse,\n      default: '[]'\n    },\n    links: {\n      parse: JSON.parse,\n      default: '[]'\n    },\n    numDimensions: {\n      type: 'number',\n      default: 3\n    },\n    dagMode: {\n      type: 'string',\n      default: ''\n    },\n    dagLevelDistance: {\n      type: 'number',\n      default: 0\n    },\n    nodeRelSize: {\n      type: 'number',\n      default: 4\n    },\n    // volume per val unit\n    nodeId: {\n      type: 'string',\n      default: 'id'\n    },\n    nodeLabel: {\n      parse: parseAccessor,\n      default: 'name'\n    },\n    nodeDesc: {\n      parse: parseAccessor,\n      default: 'desc'\n    },\n    nodeVal: {\n      parse: parseAccessor,\n      default: 'val'\n    },\n    nodeResolution: {\n      type: 'number',\n      default: 8\n    },\n    // how many slice segments in the sphere's circumference\n    nodeColor: {\n      parse: parseAccessor,\n      default: 'color'\n    },\n    nodeAutoColorBy: {\n      parse: parseAccessor,\n      default: ''\n    },\n    // color nodes with the same field equally\n    nodeOpacity: {\n      type: 'number',\n      default: 0.75\n    },\n    nodeThreeObject: {\n      parse: parseAccessor,\n      default: null\n    },\n    nodeThreeObjectExtend: {\n      parse: parseAccessor,\n      default: false\n    },\n    linkSource: {\n      type: 'string',\n      default: 'source'\n    },\n    linkTarget: {\n      type: 'string',\n      default: 'target'\n    },\n    linkLabel: {\n      parse: parseAccessor,\n      default: 'name'\n    },\n    linkDesc: {\n      parse: parseAccessor,\n      default: 'desc'\n    },\n    linkHoverPrecision: {\n      type: 'number',\n      default: 2\n    },\n    linkVisibility: {\n      parse: parseAccessor,\n      default: true\n    },\n    linkColor: {\n      parse: parseAccessor,\n      default: 'color'\n    },\n    linkAutoColorBy: {\n      parse: parseAccessor,\n      default: ''\n    },\n    // color links with the same field equally\n    linkOpacity: {\n      type: 'number',\n      default: 0.2\n    },\n    linkWidth: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkResolution: {\n      type: 'number',\n      default: 6\n    },\n    // how many radial segments in each line cylinder's geometry\n    linkCurvature: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkCurveRotation: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkMaterial: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkThreeObject: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkThreeObjectExtend: {\n      parse: parseAccessor,\n      default: false\n    },\n    linkPositionUpdate: {\n      parse: parseFn,\n      default: null\n    },\n    linkDirectionalArrowLength: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkDirectionalArrowColor: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkDirectionalArrowRelPos: {\n      parse: parseAccessor,\n      default: 0.5\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      type: 'number',\n      default: 8\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      parse: parseAccessor,\n      default: 0\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      parse: parseAccessor,\n      default: 0.01\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      parse: parseAccessor,\n      default: 0.5\n    },\n    linkDirectionalParticleColor: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkDirectionalParticleResolution: {\n      type: 'number',\n      default: 4\n    },\n    // how many slice segments in the particle sphere's circumference\n    onNodeCenterHover: {\n      parse: parseFn,\n      default: function () {}\n    },\n    onLinkCenterHover: {\n      parse: parseFn,\n      default: function () {}\n    },\n    forceEngine: {\n      type: 'string',\n      default: 'd3'\n    },\n    // 'd3' or 'ngraph'\n    d3AlphaDecay: {\n      type: 'number',\n      default: 0.0228\n    },\n    d3VelocityDecay: {\n      type: 'number',\n      default: 0.4\n    },\n    warmupTicks: {\n      type: 'int',\n      default: 0\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      type: 'int',\n      default: 1e18\n    },\n    // Simulate infinity (int parser doesn't accept Infinity object)\n    cooldownTime: {\n      type: 'int',\n      default: 15000\n    },\n    // ms\n    onEngineTick: {\n      parse: parseFn,\n      default: function () {}\n    },\n    onEngineStop: {\n      parse: parseFn,\n      default: function () {}\n    }\n  },\n  // Bind component methods\n  d3Force: function () {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    const forceGraph = this.forceGraph;\n    const returnVal = forceGraph.d3Force.apply(forceGraph, arguments);\n    return returnVal === forceGraph ? this // return self, not the inner forcegraph component\n    : returnVal;\n  },\n  refresh: function () {\n    this.forceGraph && this.forceGraph.refresh();\n    return this;\n  },\n  init: function () {\n    var state = this.state = {}; // Internal state\n    // Add info msg\n\n    state.infoEl = document.createElement('a-text');\n    state.infoEl.setAttribute('position', '0 -0.1 -1'); // Canvas center\n\n    state.infoEl.setAttribute('width', 1);\n    state.infoEl.setAttribute('align', 'center');\n    state.infoEl.setAttribute('color', 'lavender'); // Setup tooltip\n\n    state.tooltipEl = document.createElement('a-text');\n    state.tooltipEl.setAttribute('position', '0 -0.5 -1'); // Aligned to canvas bottom\n\n    state.tooltipEl.setAttribute('width', 2);\n    state.tooltipEl.setAttribute('align', 'center');\n    state.tooltipEl.setAttribute('color', 'lavender');\n    state.tooltipEl.setAttribute('value', ''); // Setup sub-tooltip\n\n    state.subTooltipEl = document.createElement('a-text');\n    state.subTooltipEl.setAttribute('position', '0 -0.6 -1'); // Aligned to canvas bottom\n\n    state.subTooltipEl.setAttribute('width', 1.5);\n    state.subTooltipEl.setAttribute('align', 'center');\n    state.subTooltipEl.setAttribute('color', 'lavender');\n    state.subTooltipEl.setAttribute('value', ''); // Get camera dom element and attach fixed view elements to camera\n\n    var cameraEl = document.querySelector('a-entity[camera], a-camera');\n    cameraEl.appendChild(state.infoEl);\n    cameraEl.appendChild(state.tooltipEl);\n    cameraEl.appendChild(state.subTooltipEl); // Keep reference to Three camera object\n\n    state.cameraObj = cameraEl.object3D.children.filter(function (child) {\n      return child.type === 'PerspectiveCamera';\n    })[0]; // On camera switch\n\n    this.el.sceneEl.addEventListener('camera-set-active', function (evt) {\n      // Switch camera reference\n      state.cameraObj = evt.detail.cameraEl.components.camera.camera;\n    }); // setup FG object\n\n    if (!this.forceGraph) this.forceGraph = new ThreeForceGraph(); // initialize forceGraph if it doesn't exist yet\n\n    this.el.object3D.add(this.forceGraph);\n    this.forceGraph.onLoading(function () {\n      state.infoEl.setAttribute('value', 'Loading...'); // Add loading msg\n    }).onFinishLoading(function () {\n      state.infoEl.setAttribute('value', '');\n    });\n  },\n  remove: function () {\n    // Clean-up elems\n    this.state.infoEl.remove();\n    this.state.tooltipEl.remove();\n    this.state.subTooltipEl.remove();\n  },\n  update: function (oldData) {\n    var comp = this,\n        elData = this.data,\n        diff = AFRAME.utils.diff(elData, oldData);\n    var fgProps = ['jsonUrl', 'numDimensions', 'dagMode', 'dagLevelDistance', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'forceEngine', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'];\n    fgProps.filter(function (p) {\n      return p in diff;\n    }).forEach(function (p) {\n      comp.forceGraph[p](elData[p] !== '' ? elData[p] : null);\n    }); // Convert blank values into nulls\n\n    if ('nodes' in diff || 'links' in diff) {\n      comp.forceGraph.graphData({\n        nodes: elData.nodes,\n        links: elData.links\n      });\n    }\n  },\n  tick: function (t, td) {\n    // Update tooltip\n    var centerRaycaster = new THREE.Raycaster();\n    centerRaycaster.linePrecision = this.data.linkHoverPrecision;\n    centerRaycaster.setFromCamera(new THREE.Vector2(0, 0), // Canvas center\n    this.state.cameraObj);\n    var intersects = centerRaycaster.intersectObjects(this.forceGraph.children).filter(function (o) {\n      // Check only node/link objects\n      return ['node', 'link'].indexOf(o.object.__graphObjType) !== -1;\n    }).sort(function (a, b) {\n      // Prioritize nodes over links\n      return isNode(b) - isNode(a);\n\n      function isNode(o) {\n        return o.object.__graphObjType === 'node';\n      }\n    });\n    var topObject = intersects.length ? intersects[0].object : null;\n\n    if (topObject !== this.state.hoverObj) {\n      const prevObjType = this.state.hoverObj ? this.state.hoverObj.__graphObjType : null;\n      const prevObjData = this.state.hoverObj ? this.state.hoverObj.__data : null;\n      const objType = topObject ? topObject.__graphObjType : null;\n      const objData = topObject ? topObject.__data : null;\n\n      if (prevObjType && prevObjType !== objType) {\n        // Hover out\n        this.data['on' + (prevObjType === 'node' ? 'Node' : 'Link') + 'CenterHover'](null, prevObjData);\n      }\n\n      if (objType) {\n        // Hover in\n        this.data['on' + (objType === 'node' ? 'Node' : 'Link') + 'CenterHover'](objData, prevObjType === objType ? prevObjData : null);\n      }\n\n      this.state.hoverObj = topObject;\n      this.state.tooltipEl.setAttribute('value', topObject ? accessorFn(this.data[topObject.__graphObjType + 'Label'])(topObject.__data) || '' : '');\n      this.state.subTooltipEl.setAttribute('value', topObject ? accessorFn(this.data[topObject.__graphObjType + 'Desc'])(topObject.__data) || '' : '');\n    } // Run force-graph ticker\n\n\n    this.forceGraph.tickFrame();\n  }\n});","map":null,"metadata":{},"sourceType":"script"}