{"ast":null,"code":"'use strict';\n\n(function () {\n  var CONSTANTS = {\n    HOLD_THRESHOLD: 8,\n    SCROLL_INTERVAL: 1000 / 60,\n    SCROLL_AREA_MAX: 50,\n    SCROLL_SPEED: 20\n  };\n  var downPos = null;\n  var mouseOffset = null;\n  var mouseDown = null;\n\n  function createOffsetStyles(event, props) {\n    var top = !props.lock || props.lock === 'horizontal' ? mouseOffset.clientY - mouseDown.clientY : 0;\n    var left = !props.lock || props.lock === 'vertical' ? mouseOffset.clientX - mouseDown.clientX : 0;\n    return 'translate(' + left + 'px,' + top + 'px)';\n  }\n\n  function getScrollOffsetX(rect, node) {\n    var positionInScrollArea;\n    var scrollLeft = node.scrollLeft;\n    var scrollWidth = node.scrollWidth;\n    var scrollAreaX = Math.min(rect.width / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollLeft > 0 && mouseOffset.clientX <= rect.left + scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.left + scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return -positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollLeft < scrollWidth - rect.width && mouseOffset.clientX >= rect.right - scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.right - scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function getScrollOffsetY(rect, node) {\n    var positionInScrollArea;\n    var scrollTop = node.scrollTop;\n    var scrollHeight = node.scrollHeight;\n    var scrollAreaY = Math.min(rect.height / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollTop > 0 && mouseOffset.clientY <= rect.top + scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.top + scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return -positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollTop < scrollHeight - rect.height && mouseOffset.clientY >= rect.bottom - scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.bottom - scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function scrollParentsX(node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n      var scrollOffsetX = getScrollOffsetX(rect, parent);\n\n      if (!scrollOffsetX) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetX) {\n        parent.scrollLeft = parent.scrollLeft + scrollOffsetX;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function scrollParentsY(node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n      var scrollOffsetY = getScrollOffsetY(rect, parent);\n\n      if (!scrollOffsetY) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetY) {\n        parent.scrollTop = parent.scrollTop + scrollOffsetY;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function Store() {\n    var activeGroup = null;\n    var draggedId = null;\n    var placedId = null;\n    var draggedElement = null;\n    var scrollInterval = null;\n    var target = null;\n    var draggedStyle = null;\n    var draggedIndex = -1;\n    var placedIndex = -1;\n    var reorderComponents = {};\n    var reorderGroups = {};\n\n    function autoScroll() {\n      if (target && target.props.autoScroll && target.rootNode) {\n        var rect = target.rootNode.getBoundingClientRect();\n\n        if (target.props.lock !== 'horizontal') {\n          var scrollOffsetX = getScrollOffsetX(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetX) {\n            scrollParentsX(target.rootNode);\n          } else if (scrollOffsetX) {\n            target.rootNode.scrollLeft = target.rootNode.scrollLeft + scrollOffsetX;\n          }\n        }\n\n        if (target.props.lock !== 'vertical') {\n          var scrollOffsetY = getScrollOffsetY(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetY) {\n            scrollParentsY(target.rootNode);\n          } else if (scrollOffsetY) {\n            target.rootNode.scrollTop = target.rootNode.scrollTop + scrollOffsetY;\n          }\n        }\n      }\n    }\n\n    function getState() {\n      return {\n        draggedId: draggedId,\n        placedId: placedId,\n        activeGroup: activeGroup,\n        draggedStyle: draggedStyle,\n        draggedIndex: draggedIndex,\n        placedIndex: placedIndex,\n        draggedElement: draggedElement\n      };\n    }\n\n    function trigger(clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      reorderComponents[draggedId].setDragState(state);\n    }\n\n    function triggerGroup(clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      for (var reorderId in reorderGroups[activeGroup]) {\n        reorderGroups[activeGroup][reorderId].setDragState(state);\n      }\n    }\n\n    function validateComponentIdAndGroup(reorderId, reorderGroup) {\n      if (typeof reorderId !== 'string') {\n        throw new Error('Expected reorderId to be a string. Instead got ' + typeof reorderId);\n      }\n\n      if (typeof reorderGroup !== 'undefined' && typeof reorderGroup !== 'string') {\n        throw new Error('Expected reorderGroup to be a string. Instead got ' + typeof reorderGroup);\n      }\n    }\n\n    function registerReorderComponent(component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup in reorderGroups && reorderId in reorderGroups[reorderGroup]) {\n          throw new Error('Duplicate reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        reorderGroups[reorderGroup] = reorderGroups[reorderGroup] || {};\n        reorderGroups[reorderGroup][reorderId] = component;\n      } else {\n        if (reorderId in reorderComponents) {\n          throw new Error('Duplicate reorderId: ' + reorderId);\n        }\n\n        reorderComponents[reorderId] = component;\n      }\n    }\n\n    function unregisterReorderComponent(component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (!(reorderGroup in reorderGroups)) {\n          throw new Error('Unknown reorderGroup: ' + reorderGroup);\n        }\n\n        if (reorderGroup in reorderGroups && !(reorderId in reorderGroups[reorderGroup])) {\n          throw new Error('Unknown reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        delete reorderGroups[reorderGroup][reorderId];\n      } else {\n        if (!(reorderId in reorderComponents)) {\n          throw new Error('Unknown reorderId: ' + reorderId);\n        }\n\n        delete reorderComponents[reorderId];\n      }\n    }\n\n    function startDrag(reorderId, reorderGroup, index, element, component) {\n      target = component;\n      clearInterval(scrollInterval);\n      scrollInterval = setInterval(autoScroll, CONSTANTS.SCROLL_INTERVAL);\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n      draggedIndex = index;\n      placedIndex = index;\n      draggedStyle = null;\n      draggedElement = element;\n      draggedId = reorderId;\n      placedId = reorderId;\n      activeGroup = null;\n\n      if (typeof reorderGroup !== 'undefined') {\n        activeGroup = reorderGroup;\n        triggerGroup();\n      } else if (draggedId !== null && reorderId === draggedId) {\n        trigger();\n      }\n    }\n\n    function stopDrag(reorderId, reorderGroup) {\n      target = null;\n      clearInterval(scrollInterval);\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (activeGroup !== null) {\n        if (reorderGroup === activeGroup) {\n          draggedIndex = -1;\n          placedIndex = -1;\n          draggedStyle = null;\n          draggedElement = null; // These need to be cleared after trigger to allow state updates to these components\n\n          triggerGroup(['activeGroup']);\n          draggedId = null;\n          placedId = null;\n          activeGroup = null;\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedIndex = -1;\n        placedIndex = -1;\n        draggedStyle = null;\n        draggedElement = null; // These need to be cleared after trigger to allow state updates to these components\n\n        trigger(['activeGroup']);\n        draggedId = null;\n        placedId = null;\n        activeGroup = null;\n      }\n    }\n\n    function setPlacedIndex(reorderId, reorderGroup, index, component) {\n      target = component;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          placedId = reorderId;\n          placedIndex = index;\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        placedIndex = index;\n        trigger();\n      }\n    }\n\n    function setDraggedStyle(reorderId, reorderGroup, style) {\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          draggedStyle = style;\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedStyle = style;\n        trigger();\n      }\n    }\n\n    this.getState = getState;\n    this.registerReorderComponent = registerReorderComponent;\n    this.unregisterReorderComponent = unregisterReorderComponent;\n    this.startDrag = startDrag;\n    this.stopDrag = stopDrag;\n    this.setPlacedIndex = setPlacedIndex;\n    this.setDraggedStyle = setDraggedStyle;\n  }\n\n  var store = new Store();\n\n  function reorder(list, previousIndex, nextIndex) {\n    var copy = [].concat(list);\n    var item = copy.splice(previousIndex, 1)[0];\n    copy.splice(nextIndex, 0, item);\n    return copy;\n  }\n\n  function reorderImmutable(list, previousIndex, nextIndex) {\n    var item = list.get(previousIndex);\n    return list.delete(previousIndex).splice(nextIndex, 0, item);\n  }\n\n  function reorderFromTo(lists, previousIndex, nextIndex) {\n    var previousList = [].concat(lists.from);\n    var nextList = [].concat(lists.to);\n    var item = previousList.splice(previousIndex, 1)[0];\n    nextList.splice(nextIndex, 0, item);\n    return {\n      from: previousList,\n      to: nextList\n    };\n  }\n\n  function reorderFromToImmutable(lists, previousIndex, nextIndex) {\n    var item = lists.from.get(previousIndex);\n    return {\n      from: lists.from.delete(previousIndex),\n      to: lists.to.splice(nextIndex, 0, item)\n    };\n  }\n\n  function withReorderMethods(Reorder) {\n    Reorder.reorder = reorder;\n    Reorder.reorderImmutable = reorderImmutable;\n    Reorder.reorderFromTo = reorderFromTo;\n    Reorder.reorderFromToImmutable = reorderFromToImmutable;\n    return Reorder;\n  }\n\n  function assign() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (!args.length) {\n      return undefined;\n    }\n\n    if (args.length === 1) {\n      return args[0];\n    }\n\n    var obj = args.shift();\n\n    while (args.length) {\n      var arg = args.shift();\n\n      for (var key in arg) {\n        obj[key] = arg[key];\n      }\n    }\n\n    return obj;\n  }\n\n  function getReorderComponent(React, ReactDOM, createReactClass, PropTypes) {\n    var Reorder = createReactClass({\n      displayName: 'Reorder',\n      getInitialState: function () {\n        return store.getState();\n      },\n      isDragging: function () {\n        return this.state.draggedIndex >= 0;\n      },\n      isPlacing: function () {\n        return this.state.placedIndex >= 0;\n      },\n      isDraggingFrom: function () {\n        return this.props.reorderId === this.state.draggedId;\n      },\n      isPlacingTo: function () {\n        return this.props.reorderId === this.state.placedId;\n      },\n      isInvolvedInDragging: function () {\n        return this.props.reorderId === this.state.draggedId || this.props.reorderGroup === this.state.activeGroup;\n      },\n      preventContextMenu: function (event) {\n        if (downPos && this.props.disableContextMenus) {\n          event.preventDefault();\n        }\n      },\n      preventNativeScrolling: function (event) {\n        event.preventDefault();\n      },\n      persistEvent: function (event) {\n        if (typeof event.persist === 'function') {\n          event.persist();\n        }\n      },\n      copyTouchKeys: function (event) {\n        if (event.touches && event.touches[0]) {\n          this.persistEvent(event);\n          event.clientX = event.touches[0].clientX;\n          event.clientY = event.touches[0].clientY;\n        }\n      },\n      xCollision: function (event, rect) {\n        return event.clientX >= rect.left && event.clientX <= rect.right;\n      },\n      yCollision: function (event, rect) {\n        return event.clientY >= rect.top && event.clientY <= rect.bottom;\n      },\n      findCollisionIndex: function (event, listElements) {\n        for (var i = 0; i < listElements.length; i += 1) {\n          if (!listElements[i].getAttribute('data-placeholder') && !listElements[i].getAttribute('data-dragged')) {\n            var rect = listElements[i].getBoundingClientRect();\n\n            switch (this.props.lock) {\n              case 'horizontal':\n                if (this.yCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n\n              case 'vertical':\n                if (this.xCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n\n              default:\n                if (this.yCollision(event, rect) && this.xCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n            }\n          }\n        }\n\n        return -1;\n      },\n      collidesWithElement: function (event, element) {\n        var rect = element.getBoundingClientRect();\n        return this.yCollision(event, rect) && this.xCollision(event, rect);\n      },\n      getHoldTime: function (event) {\n        if (event.touches && typeof this.props.touchHoldTime !== 'undefined') {\n          return parseInt(this.props.touchHoldTime, 10) || 0;\n        } else if (typeof this.props.mouseHoldTime !== 'undefined') {\n          return parseInt(this.props.mouseHoldTime, 10) || 0;\n        }\n\n        return parseInt(this.props.holdTime, 10) || 0;\n      },\n      startDrag: function (event, target, index) {\n        if (!this.moved) {\n          var rect = target.getBoundingClientRect();\n          var draggedStyle = {\n            position: 'fixed',\n            top: rect.top,\n            left: rect.left,\n            width: rect.width,\n            height: rect.height\n          };\n          store.startDrag(this.props.reorderId, this.props.reorderGroup, index, this.props.children[index], this);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, draggedStyle);\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n          mouseDown = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n      // Begin dragging index, set initial drag style, set placeholder position, calculate mouse offset\n      onItemDown: function (callback, index, event) {\n        if (typeof callback === 'function') {\n          callback(event);\n        }\n\n        if (event.button === 2 || this.props.disabled) {\n          return;\n        }\n\n        this.copyTouchKeys(event);\n        this.moved = false;\n        downPos = {\n          clientX: event.clientX,\n          clientY: event.clientY\n        };\n        var holdTime = this.getHoldTime(event);\n        var target = event.currentTarget;\n\n        if (holdTime) {\n          this.persistEvent(event);\n          this.holdTimeout = setTimeout(this.startDrag.bind(this, event, target, index), holdTime);\n        } else {\n          this.startDrag(event, target, index);\n        }\n      },\n      // Stop dragging - reset style & draggedIndex, handle reorder\n      onWindowUp: function (event) {\n        clearTimeout(this.holdTimeout);\n\n        if (this.isDragging() && this.isDraggingFrom()) {\n          var fromIndex = this.state.draggedIndex;\n          var toIndex = this.state.placedIndex;\n          store.stopDrag(this.props.reorderId, this.props.reorderGroup);\n\n          if (fromIndex >= 0 && (fromIndex !== toIndex || this.state.draggedId !== this.state.placedId) && typeof this.props.onReorder === 'function') {\n            this.props.onReorder(event, fromIndex, toIndex - (this.state.draggedId === this.state.placedId && fromIndex < toIndex ? 1 : 0), this.state.draggedId, this.state.placedId);\n          }\n        }\n\n        downPos = null;\n        mouseOffset = null;\n        mouseDown = null;\n      },\n      // Update dragged position & placeholder index, invalidate drag if moved\n      onWindowMove: function (event) {\n        this.copyTouchKeys(event);\n\n        if (downPos && (Math.abs(event.clientX - downPos.clientX) >= CONSTANTS.HOLD_THRESHOLD || Math.abs(event.clientY - downPos.clientY) >= CONSTANTS.HOLD_THRESHOLD)) {\n          this.moved = true;\n        }\n\n        if (this.isDragging() && this.isInvolvedInDragging()) {\n          this.preventNativeScrolling(event);\n          var element = this.rootNode;\n\n          if (this.collidesWithElement(event, element)) {\n            var children = element.childNodes;\n            var collisionIndex = this.findCollisionIndex(event, children);\n\n            if (collisionIndex <= this.props.children.length && collisionIndex >= 0) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, collisionIndex, this);\n            } else if (typeof this.props.reorderGroup !== 'undefined' && ( // Is part of a group\n            !this.props.children || !this.props.children.length || // If all items removed\n            this.isDraggingFrom() && this.props.children.length === 1 // If dragging back to a now empty list\n            )) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, 0, this);\n            }\n          }\n\n          this.state.draggedStyle.transform = createOffsetStyles(event, this.props);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, this.state.draggedStyle);\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n      setDragState: function (state) {\n        var isPartOfGroup = this.props.reorderGroup;\n        var isGroupDragged = state.activeGroup;\n        var storedActiveGroup = this.state.activeGroup;\n        var wasGroupDragged = !isGroupDragged && storedActiveGroup;\n        var isActiveGroup = isPartOfGroup && isGroupDragged && state.activeGroup === this.props.reorderGroup;\n        var isDragged = this.props.reorderId === state.draggedId;\n        var isPlaced = this.props.reorderId === state.placedId;\n        var wasPlaced = this.props.reorderId === this.state.placedId; // This check is like a shouldComponentUpdate but specific to our store state\n        // Allowing prop changes to update the component\n\n        if (!isGroupDragged && !isPartOfGroup && (isDragged || isPlaced) || isPartOfGroup && (!storedActiveGroup || wasGroupDragged) || wasGroupDragged || isActiveGroup && (isDragged || isPlaced || wasPlaced)) {\n          this.setState(state);\n        }\n      },\n      // Add listeners and store root node\n      componentDidMount: function () {\n        store.registerReorderComponent(this);\n        window.addEventListener('mouseup', this.onWindowUp, {\n          passive: false\n        });\n        window.addEventListener('touchend', this.onWindowUp, {\n          passive: false\n        });\n        window.addEventListener('mousemove', this.onWindowMove, {\n          passive: false\n        });\n        window.addEventListener('touchmove', this.onWindowMove, {\n          passive: false\n        });\n        window.addEventListener('contextmenu', this.preventContextMenu, {\n          passive: false\n        });\n        this.storeRootNode();\n      },\n      // Remove listeners\n      componentWillUnmount: function () {\n        store.unregisterReorderComponent(this);\n        clearTimeout(this.holdTimeout);\n        window.removeEventListener('mouseup', this.onWindowUp);\n        window.removeEventListener('touchend', this.onWindowUp);\n        window.removeEventListener('mousemove', this.onWindowMove);\n        window.removeEventListener('touchmove', this.onWindowMove);\n        window.removeEventListener('contextmenu', this.preventContextMenu);\n      },\n      storeRootNode: function () {\n        var element = ReactDOM.findDOMNode(this);\n        this.rootNode = element;\n\n        if (typeof this.props.getRef === 'function') {\n          this.props.getRef(element);\n        }\n      },\n      render: function () {\n        var children = this.props.children && this.props.children.map(function (child, index) {\n          var isDragged = this.isDragging() && this.isDraggingFrom() && index === this.state.draggedIndex;\n          var draggedStyle = isDragged ? assign({}, child.props.style, this.state.draggedStyle) : child.props.style;\n          var draggedClass = [child.props.className || '', isDragged ? this.props.draggedClassName : ''].join(' ');\n          return React.cloneElement(isDragged ? this.state.draggedElement : child, {\n            style: draggedStyle,\n            className: draggedClass,\n            onMouseDown: this.onItemDown.bind(this, child.props.onMouseDown, index),\n            onTouchStart: this.onItemDown.bind(this, child.props.onTouchStart, index),\n            'data-dragged': isDragged ? true : null\n          });\n        }.bind(this));\n        var placeholderElement = this.props.placeholder || this.state.draggedElement;\n\n        if (this.isPlacing() && this.isPlacingTo() && placeholderElement) {\n          var placeholder = React.cloneElement(placeholderElement, {\n            key: 'react-reorder-placeholder',\n            className: [placeholderElement.props.className || '', this.props.placeholderClassName].join(' '),\n            'data-placeholder': true\n          });\n          children.splice(this.state.placedIndex, 0, placeholder);\n        }\n\n        return React.createElement(this.props.component, {\n          className: this.props.className,\n          id: this.props.id,\n          style: this.props.style,\n          onClick: this.props.onClick\n        }, children);\n      }\n    });\n    Reorder.propTypes = {\n      component: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n      getRef: PropTypes.func,\n      reorderId: PropTypes.string,\n      reorderGroup: PropTypes.string,\n      placeholderClassName: PropTypes.string,\n      draggedClassName: PropTypes.string,\n      lock: PropTypes.string,\n      holdTime: PropTypes.number,\n      touchHoldTime: PropTypes.number,\n      mouseHoldTime: PropTypes.number,\n      onReorder: PropTypes.func,\n      placeholder: PropTypes.element,\n      autoScroll: PropTypes.bool,\n      autoScrollParents: PropTypes.bool,\n      disabled: PropTypes.bool,\n      disableContextMenus: PropTypes.bool\n    };\n    Reorder.defaultProps = {\n      component: 'div',\n      // getRef: function,\n      // reorderId: id,\n      // reorderGroup: group,\n      placeholderClassName: 'placeholder',\n      draggedClassName: 'dragged',\n      // lock: direction,\n      holdTime: 0,\n      // touchHoldTime: 0,\n      // mouseHoldTime: 0,\n      // onReorder: function,\n      // placeholder: react element\n      autoScroll: true,\n      autoScrollParents: true,\n      disabled: false,\n      disableContextMenus: true\n    };\n    return Reorder;\n  }\n  /* istanbul ignore next */\n  // Export for commonjs / browserify\n\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    var React = require('react'); // eslint-disable-line no-undef\n\n\n    var ReactDOM = require('react-dom'); // eslint-disable-line no-undef\n\n\n    var createReactClass = require('create-react-class'); // eslint-disable-line no-undef\n\n\n    var PropTypes = require('prop-types'); // eslint-disable-line no-undef\n\n\n    module.exports = withReorderMethods( // eslint-disable-line no-undef\n    getReorderComponent(React, ReactDOM, createReactClass, PropTypes)); // Export for amd / require\n  } else if (typeof define === 'function' && define.amd) {\n    // eslint-disable-line no-undef\n    define( // eslint-disable-line no-undef\n    ['react', 'react-dom', 'create-react-class', 'prop-types'], function (ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD) {\n      return withReorderMethods(getReorderComponent(ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD));\n    }); // Export globally\n  } else {\n    var root;\n\n    if (typeof window !== 'undefined') {\n      root = window;\n    } else if (typeof global !== 'undefined') {\n      root = global; // eslint-disable-line no-undef\n    } else if (typeof self !== 'undefined') {\n      root = self; // eslint-disable-line no-undef\n    } else {\n      root = this;\n    }\n\n    root.Reorder = withReorderMethods(getReorderComponent(root.React, root.ReactDOM, root.createReactClass, root.PropTypes));\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}