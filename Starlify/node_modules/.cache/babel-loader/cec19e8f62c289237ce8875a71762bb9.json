{"ast":null,"code":"/*!\n * @pixi/canvas-mesh - v5.0.4\n * Compiled Fri, 07 Jun 2019 17:17:49 UTC\n *\n * @pixi/canvas-mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { DRAW_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { MeshMaterial, Mesh } from '@pixi/mesh';\nimport { CanvasTinter } from '@pixi/canvas-renderer';\nimport { NineSlicePlane, SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasMeshRenderer = function CanvasMeshRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders the Mesh\n *\n * @param {PIXI.Mesh} mesh - the Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype.render = function render(mesh) {\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var transform = mesh.worldTransform;\n  var res = renderer.resolution;\n\n  if (mesh.roundPixels) {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n  } else {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n  }\n\n  renderer.context.globalAlpha = mesh.worldAlpha;\n  renderer.setBlendMode(mesh.blendMode);\n\n  if (mesh.drawMode !== DRAW_MODES.TRIANGLES) {\n    this._renderTriangleMesh(mesh);\n  } else {\n    this._renderTriangles(mesh);\n  }\n};\n/**\n * Draws the object in Triangle Mesh mode\n *\n * @private\n * @param {PIXI.Mesh} mesh - the Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {\n  // draw triangles!!\n  var length = mesh.geometry.buffers[0].data.length;\n\n  for (var i = 0; i < length - 2; i++) {\n    // draw some triangles!\n    var index = i * 2;\n\n    this._renderDrawTriangle(mesh, index, index + 2, index + 4);\n  }\n};\n/**\n * Draws the object in triangle mode using canvas\n *\n * @private\n * @param {PIXI.Mesh} mesh - the current mesh\n */\n\n\nCanvasMeshRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {\n  // draw triangles!!\n  var indices = mesh.geometry.getIndex().data;\n  var length = indices.length;\n\n  for (var i = 0; i < length; i += 3) {\n    // draw some triangles!\n    var index0 = indices[i] * 2;\n    var index1 = indices[i + 1] * 2;\n    var index2 = indices[i + 2] * 2;\n\n    this._renderDrawTriangle(mesh, index0, index1, index2);\n  }\n};\n/**\n * Draws one of the triangles that from the Mesh\n *\n * @private\n * @param {PIXI.Mesh} mesh - the current mesh\n * @param {number} index0 - the index of the first vertex\n * @param {number} index1 - the index of the second vertex\n * @param {number} index2 - the index of the third vertex\n */\n\n\nCanvasMeshRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {\n  var context = this.renderer.context;\n  var vertices = mesh.geometry.buffers[0].data;\n  var uvs = mesh.uvs;\n  var texture = mesh.texture;\n\n  if (!texture.valid) {\n    return;\n  }\n\n  var base = texture.baseTexture;\n  var textureSource = base.getDrawableSource();\n  var textureWidth = base.width;\n  var textureHeight = base.height;\n  var u0 = uvs[index0] * base.width;\n  var u1 = uvs[index1] * base.width;\n  var u2 = uvs[index2] * base.width;\n  var v0 = uvs[index0 + 1] * base.height;\n  var v1 = uvs[index1 + 1] * base.height;\n  var v2 = uvs[index2 + 1] * base.height;\n  var x0 = vertices[index0];\n  var x1 = vertices[index1];\n  var x2 = vertices[index2];\n  var y0 = vertices[index0 + 1];\n  var y1 = vertices[index1 + 1];\n  var y2 = vertices[index2 + 1];\n  var canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n  if (canvasPadding > 0) {\n    var paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n    var paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n    var centerX = (x0 + x1 + x2) / 3;\n    var centerY = (y0 + y1 + y2) / 3;\n    var normX = x0 - centerX;\n    var normY = y0 - centerY;\n    var dist = Math.sqrt(normX * normX + normY * normY);\n    x0 = centerX + normX / dist * (dist + paddingX);\n    y0 = centerY + normY / dist * (dist + paddingY); //\n\n    normX = x1 - centerX;\n    normY = y1 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x1 = centerX + normX / dist * (dist + paddingX);\n    y1 = centerY + normY / dist * (dist + paddingY);\n    normX = x2 - centerX;\n    normY = y2 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x2 = centerX + normX / dist * (dist + paddingX);\n    y2 = centerY + normY / dist * (dist + paddingY);\n  }\n\n  context.save();\n  context.beginPath();\n  context.moveTo(x0, y0);\n  context.lineTo(x1, y1);\n  context.lineTo(x2, y2);\n  context.closePath();\n  context.clip(); // Compute matrix transform\n\n  var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;\n  var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;\n  var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;\n  var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;\n  var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;\n  var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;\n  var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;\n  context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);\n  context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);\n  context.restore();\n  this.renderer.invalidateBlendMode();\n};\n/**\n * Renders a flat Mesh\n *\n * @private\n * @param {PIXI.Mesh} mesh - The Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {\n  var context = this.renderer.context;\n  var vertices = mesh.geometry.getBuffer('aVertexPosition').data;\n  var length = vertices.length / 2; // this.count++;\n\n  context.beginPath();\n\n  for (var i = 1; i < length - 2; ++i) {\n    // draw some triangles!\n    var index = i * 2;\n    var x0 = vertices[index];\n    var y0 = vertices[index + 1];\n    var x1 = vertices[index + 2];\n    var y1 = vertices[index + 3];\n    var x2 = vertices[index + 4];\n    var y2 = vertices[index + 5];\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n  }\n\n  context.fillStyle = '#FF0000';\n  context.fill();\n  context.closePath();\n};\n/**\n * destroy the the renderer.\n *\n */\n\n\nCanvasMeshRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n/**\n * Default `canvasPadding` for canvas-based Mesh rendering.\n *\n * @see PIXI.Mesh2d#canvasPadding\n * @static\n * @name MESH_CANVAS_PADDING\n * @memberof PIXI.settings\n * @type {number}\n * @default 0\n */\n\n\nsettings.MESH_CANVAS_PADDING = 0;\n/**\n * Renders the mesh using the Canvas renderer\n *\n * @protected\n * @method render\n * @memberof PIXI.MeshMaterial#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n * @param {PIXI.Mesh} mesh - Mesh to render.\n */\n\nMeshMaterial.prototype._renderCanvas = function _renderCanvas(renderer, mesh) {\n  renderer.plugins.mesh.render(mesh);\n};\n/**\n * Cached tint value so we can tell when the tint is changed.\n * @memberof PIXI.NineSlicePlane#\n * @member {number} _cachedTint\n * @protected\n */\n\n\nNineSlicePlane.prototype._cachedTint = 0xFFFFFF;\n/**\n * Cached tinted texture.\n * @memberof PIXI.NineSlicePlane#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\n\nNineSlicePlane.prototype._tintedCanvas = null;\n/**\n * Temporary storage for canvas source coords\n * @memberof PIXI.NineSlicePlane#\n * @member {number[]} _canvasUvs\n * @private\n */\n\nNineSlicePlane.prototype._canvasUvs = null;\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.NineSlicePlane#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer to render with.\n */\n\nNineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer) {\n  var context = renderer.context;\n  var transform = this.worldTransform;\n  var res = renderer.resolution;\n  var isTinted = this.tint !== 0xFFFFFF;\n  var texture = this._texture; // Work out tinting\n\n  if (isTinted) {\n    if (this._cachedTint !== this.tint) {\n      // Tint has changed, need to update the tinted texture and use that instead\n      this._cachedTint = this.tint;\n      this._tintedCanvas = CanvasTinter.getTintedCanvas(this, this.tint);\n    }\n  }\n\n  var textureSource = !isTinted ? texture.baseTexture.source : this._tintedCanvas;\n\n  if (!this._canvasUvs) {\n    this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];\n  }\n\n  var vertices = this.vertices;\n  var uvs = this._canvasUvs;\n  var u0 = isTinted ? 0 : texture.frame.x;\n  var v0 = isTinted ? 0 : texture.frame.y;\n  var u1 = u0 + texture.frame.width;\n  var v1 = v0 + texture.frame.height;\n  uvs[0] = u0;\n  uvs[1] = u0 + this._leftWidth;\n  uvs[2] = u1 - this._rightWidth;\n  uvs[3] = u1;\n  uvs[4] = v0;\n  uvs[5] = v0 + this._topHeight;\n  uvs[6] = v1 - this._bottomHeight;\n  uvs[7] = v1;\n\n  for (var i = 0; i < 8; i++) {\n    uvs[i] *= texture.baseTexture.resolution;\n  }\n\n  context.globalAlpha = this.worldAlpha;\n  renderer.setBlendMode(this.blendMode);\n\n  if (this.roundPixels) {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n  } else {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n  }\n\n  for (var row = 0; row < 3; row++) {\n    for (var col = 0; col < 3; col++) {\n      var ind = col * 2 + row * 8;\n      var sw = Math.max(1, uvs[col + 1] - uvs[col]);\n      var sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);\n      var dw = Math.max(1, vertices[ind + 10] - vertices[ind]);\n      var dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);\n      context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh, vertices[ind], vertices[ind + 1], dw, dh);\n    }\n  }\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\n\nMesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.shader.uvMatrix) {\n    this.shader.uvMatrix.update();\n    this.calculateUvs();\n  }\n\n  this.material._renderCanvas(renderer, this);\n}; // IMPORTANT: Please do NOT use this as a precedent to use `settings` after the object is created\n// this was merely created to completely decouple canvas from the base Mesh class and we are\n// unable to add `canvasPadding` in the constructor anymore, as the case was for PixiJS v4.\n\n/**\n * Internal variable for `canvasPadding`.\n *\n * @private\n * @memberof PIXI.Mesh\n * @member {number}\n * @default null\n */\n\n\nMesh.prototype._canvasPadding = null;\n/**\n * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n * to overlap a bit with each other. To set the global default, set {@link PIXI.settings.MESH_CANVAS_PADDING}\n *\n * @see PIXI.settings.MESH_CANVAS_PADDING\n * @member {number} canvasPadding\n * @memberof PIXI.SimpleMesh#\n * @default 0\n */\n\nObject.defineProperty(Mesh.prototype, 'canvasPadding', {\n  get: function get() {\n    return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;\n  },\n  set: function set(value) {\n    this._canvasPadding = value;\n  }\n});\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\nSimpleMesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.autoUpdate) {\n    this.geometry.getBuffer('aVertexPosition').update();\n  }\n\n  if (this.shader.update) {\n    this.shader.update();\n  }\n\n  this.calculateUvs();\n\n  this.material._renderCanvas(renderer, this);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\n\nSimpleRope.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.autoUpdate || this.geometry.width !== this.shader.texture.height) {\n    this.geometry.width = this.shader.texture.height;\n    this.geometry.update();\n  }\n\n  if (this.shader.update) {\n    this.shader.update();\n  }\n\n  this.calculateUvs();\n\n  this.material._renderCanvas(renderer, this);\n};\n\nexport { CanvasMeshRenderer };","map":null,"metadata":{},"sourceType":"module"}