{"ast":null,"code":"/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = physicsSimulator;\n\nfunction physicsSimulator(settings) {\n  var Spring = require('./lib/spring');\n\n  var expose = require('ngraph.expose');\n\n  var merge = require('ngraph.merge');\n\n  var eventify = require('ngraph.events');\n\n  settings = merge(settings, {\n    /**\n     * Ideal length for links (springs in physical model).\n     */\n    springLength: 30,\n\n    /**\n     * Hook's law coefficient. 1 - solid spring.\n     */\n    springCoeff: 0.0008,\n\n    /**\n     * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n     * if you make it positive nodes start attract each other :).\n     */\n    gravity: -1.2,\n\n    /**\n     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n     * The closer it's to 1 the more nodes algorithm will have to go through.\n     * Setting it to one makes Barnes Hut simulation no different from\n     * brute-force forces calculation (each node is considered).\n     */\n    theta: 0.8,\n\n    /**\n     * Drag force coefficient. Used to slow down system, thus should be less than 1.\n     * The closer it is to 0 the less tight system will be.\n     */\n    dragCoeff: 0.02,\n\n    /**\n     * Default time step (dt) for forces integration\n     */\n    timeStep: 20,\n\n    /**\n      * Maximum movement of the system which can be considered as stabilized\n      */\n    stableThreshold: 0.009\n  }); // We allow clients to override basic factory methods:\n\n  var createQuadTree = settings.createQuadTree || require('ngraph.quadtreebh');\n\n  var createBounds = settings.createBounds || require('./lib/bounds');\n\n  var createDragForce = settings.createDragForce || require('./lib/dragForce');\n\n  var createSpringForce = settings.createSpringForce || require('./lib/springForce');\n\n  var integrate = settings.integrator || require('./lib/eulerIntegrator');\n\n  var createBody = settings.createBody || require('./lib/createBody');\n\n  var bodies = [],\n      // Bodies in this simulation.\n  springs = [],\n      // Springs in this simulation.\n  quadTree = createQuadTree(settings),\n      bounds = createBounds(bodies, settings),\n      springForce = createSpringForce(settings),\n      dragForce = createDragForce(settings);\n  var totalMovement = 0; // how much movement we made on last step\n\n  var lastStable = false; // indicates whether system was stable on last step() call\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      accumulateForces();\n      totalMovement = integrate(bodies, settings.timeStep);\n      bounds.update();\n      var stableNow = totalMovement < settings.stableThreshold;\n\n      if (lastStable !== stableNow) {\n        publicApi.fire('stable', stableNow);\n      }\n\n      lastStable = stableNow;\n      return stableNow;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n\n      bodies.push(body);\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n\n      var body = createBody(pos);\n      bodies.push(body);\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) {\n        return;\n      }\n\n      var idx = bodies.indexOf(body);\n\n      if (idx < 0) {\n        return;\n      }\n\n      bodies.splice(idx, 1);\n\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springWeight, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);\n      springs.push(spring); // TODO: could mark simulator as dirty.\n\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) {\n        return;\n      }\n\n      var idx = springs.indexOf(spring);\n\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: function () {\n      return bounds.box;\n    },\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({\n          gravity: value\n        });\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({\n          theta: value\n        });\n        return this;\n      } else {\n        return settings.theta;\n      }\n    }\n  }; // allow settings modification via public API:\n\n  expose(settings, publicApi);\n  eventify(publicApi);\n  return publicApi;\n\n  function accumulateForces() {\n    // Accumulate forces acting on bodies.\n    var body,\n        i = bodies.length;\n\n    if (i) {\n      // only add bodies if there the array is not empty:\n      quadTree.insertBodies(bodies); // performance: O(n * log n)\n\n      while (i--) {\n        body = bodies[i]; // If body is pinned there is no point updating its forces - it should\n        // never move:\n\n        if (!body.isPinned) {\n          body.force.reset();\n          quadTree.updateBodyForce(body);\n          dragForce.update(body);\n        }\n      }\n    }\n\n    i = springs.length;\n\n    while (i--) {\n      springForce.update(springs[i]);\n    }\n  }\n}\n\n;","map":null,"metadata":{},"sourceType":"script"}