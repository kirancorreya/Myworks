{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.eachSeries = eachSeries;\nexports.queue = queue;\n/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\n\nfunction _noop() {}\n/* empty */\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\n\n\nfunction eachSeries(array, iterator, callback, deferNext) {\n  var i = 0;\n  var len = array.length;\n\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    if (deferNext) {\n      setTimeout(function () {\n        iterator(array[i++], next);\n      }, 1);\n    } else {\n      iterator(array[i++], next);\n    }\n  })();\n}\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\n\n\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\n\n\nfunction queue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function push(data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function kill() {\n      workers = 0;\n      q.drain = _noop;\n      q.started = false;\n      q._tasks = [];\n    },\n    unshift: function unshift(data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function process() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        workers += 1;\n\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function length() {\n      return q._tasks.length;\n    },\n    running: function running() {\n      return workers;\n    },\n    idle: function idle() {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function pause() {\n      if (q.paused === true) {\n        return;\n      }\n\n      q.paused = true;\n    },\n    resume: function resume() {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false; // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        return q.drain();\n      }, 1);\n      return;\n    }\n\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n\n    setTimeout(function () {\n      return q.process();\n    }, 1);\n  }\n\n  function _next(task) {\n    return function next() {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  return q;\n}","map":null,"metadata":{},"sourceType":"script"}