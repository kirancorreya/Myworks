{"ast":null,"code":"module.exports = AFRAME.registerComponent('nav-agent', {\n  schema: {\n    destination: {\n      type: 'vec3'\n    },\n    active: {\n      default: false\n    },\n    speed: {\n      default: 2\n    }\n  },\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.system.addAgent(this);\n    this.group = null;\n    this.path = [];\n    this.raycaster = new THREE.Raycaster();\n  },\n  remove: function () {\n    this.system.removeAgent(this);\n  },\n  update: function () {\n    this.path.length = 0;\n  },\n  updateNavLocation: function () {\n    this.group = null;\n    this.path = [];\n  },\n  tick: function () {\n    const vDest = new THREE.Vector3();\n    const vDelta = new THREE.Vector3();\n    const vNext = new THREE.Vector3();\n    return function (t, dt) {\n      const el = this.el;\n      const data = this.data;\n      const raycaster = this.raycaster;\n      const speed = data.speed * dt / 1000;\n      if (!data.active) return; // Use PatrolJS pathfinding system to get shortest path to target.\n\n      if (!this.path.length) {\n        const position = this.el.object3D.position;\n        this.group = this.group || this.system.getGroup(position);\n        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];\n        el.emit('navigation-start');\n      } // If no path is found, exit.\n\n\n      if (!this.path.length) {\n        console.warn('[nav] Unable to find path to %o.', data.destination);\n        this.el.setAttribute('nav-agent', {\n          active: false\n        });\n        el.emit('navigation-end');\n        return;\n      } // Current segment is a vector from current position to next waypoint.\n\n\n      const vCurrent = el.object3D.position;\n      const vWaypoint = this.path[0];\n      vDelta.subVectors(vWaypoint, vCurrent);\n      const distance = vDelta.length();\n      let gazeTarget;\n\n      if (distance < speed) {\n        // If <1 step from current waypoint, discard it and move toward next.\n        this.path.shift(); // After discarding the last waypoint, exit pathfinding.\n\n        if (!this.path.length) {\n          this.el.setAttribute('nav-agent', {\n            active: false\n          });\n          el.emit('navigation-end');\n          return;\n        }\n\n        vNext.copy(vCurrent);\n        gazeTarget = this.path[0];\n      } else {\n        // If still far away from next waypoint, find next position for\n        // the current frame.\n        vNext.copy(vDelta.setLength(speed)).add(vCurrent);\n        gazeTarget = vWaypoint;\n      } // Look at the next waypoint.\n\n\n      gazeTarget.y = vCurrent.y;\n      el.object3D.lookAt(gazeTarget); // Raycast against the nav mesh, to keep the agent moving along the\n      // ground, not traveling in a straight line from higher to lower waypoints.\n\n      raycaster.ray.origin.copy(vNext);\n      raycaster.ray.origin.y += 1.5;\n      raycaster.ray.direction.y = -1;\n      const intersections = raycaster.intersectObject(this.system.getNavMesh());\n\n      if (!intersections.length) {\n        // Raycasting failed. Step toward the waypoint and hope for the best.\n        vCurrent.copy(vNext);\n      } else {\n        // Re-project next position onto nav mesh.\n        vDelta.subVectors(intersections[0].point, vCurrent);\n        vCurrent.add(vDelta.setLength(speed));\n      }\n    };\n  }()\n});","map":null,"metadata":{},"sourceType":"script"}