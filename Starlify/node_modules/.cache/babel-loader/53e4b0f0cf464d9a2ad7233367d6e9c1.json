{"ast":null,"code":"/*!\n * @pixi/math - v5.0.4\n * Compiled Fri, 07 Jun 2019 17:17:49 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents\n * the horizontal axis and y represents the vertical axis.\n *\n * @class\n * @memberof PIXI\n */\nvar Point = function Point(x, y) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.x = x;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.y = y;\n};\n/**\n * Creates a clone of this point\n *\n * @return {PIXI.Point} a copy of the point\n */\n\n\nPoint.prototype.clone = function clone() {\n  return new Point(this.x, this.y);\n};\n/**\n * Copies x and y from the given point\n *\n * @param {PIXI.IPoint} p - The point to copy from\n * @returns {PIXI.IPoint} Returns itself.\n */\n\n\nPoint.prototype.copyFrom = function copyFrom(p) {\n  this.set(p.x, p.y);\n  return this;\n};\n/**\n * Copies x and y into the given point\n *\n * @param {PIXI.IPoint} p - The point to copy.\n * @returns {PIXI.IPoint} Given point with values updated\n */\n\n\nPoint.prototype.copyTo = function copyTo(p) {\n  p.set(this.x, this.y);\n  return p;\n};\n/**\n * Returns true if the given point is equal to this point\n *\n * @param {PIXI.IPoint} p - The point to check\n * @returns {boolean} Whether the given point equal to this point\n */\n\n\nPoint.prototype.equals = function equals(p) {\n  return p.x === this.x && p.y === this.y;\n};\n/**\n * Sets the point to a new x and y position.\n * If y is omitted, both x and y will be set to x.\n *\n * @param {number} [x=0] - position of the point on the x axis\n * @param {number} [y=0] - position of the point on the y axis\n */\n\n\nPoint.prototype.set = function set(x, y) {\n  this.x = x || 0;\n  this.y = y || (y !== 0 ? this.x : 0);\n};\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents\n * the horizontal axis and y represents the vertical axis.\n *\n * An ObservablePoint is a point that triggers a callback when the point's position is changed.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar ObservablePoint = function ObservablePoint(cb, scope, x, y) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  this._x = x;\n  this._y = y;\n  this.cb = cb;\n  this.scope = scope;\n};\n\nvar prototypeAccessors = {\n  x: {\n    configurable: true\n  },\n  y: {\n    configurable: true\n  }\n};\n/**\n * Creates a clone of this point.\n * The callback and scope params can be overidden otherwise they will default\n * to the clone object's values.\n *\n * @override\n * @param {Function} [cb=null] - callback when changed\n * @param {object} [scope=null] - owner of callback\n * @return {PIXI.ObservablePoint} a copy of the point\n */\n\nObservablePoint.prototype.clone = function clone(cb, scope) {\n  if (cb === void 0) cb = null;\n  if (scope === void 0) scope = null;\n\n  var _cb = cb || this.cb;\n\n  var _scope = scope || this.scope;\n\n  return new ObservablePoint(_cb, _scope, this._x, this._y);\n};\n/**\n * Sets the point to a new x and y position.\n * If y is omitted, both x and y will be set to x.\n *\n * @param {number} [x=0] - position of the point on the x axis\n * @param {number} [y=0] - position of the point on the y axis\n */\n\n\nObservablePoint.prototype.set = function set(x, y) {\n  var _x = x || 0;\n\n  var _y = y || (y !== 0 ? _x : 0);\n\n  if (this._x !== _x || this._y !== _y) {\n    this._x = _x;\n    this._y = _y;\n    this.cb.call(this.scope);\n  }\n};\n/**\n * Copies x and y from the given point\n *\n * @param {PIXI.IPoint} p - The point to copy from.\n * @returns {PIXI.IPoint} Returns itself.\n */\n\n\nObservablePoint.prototype.copyFrom = function copyFrom(p) {\n  if (this._x !== p.x || this._y !== p.y) {\n    this._x = p.x;\n    this._y = p.y;\n    this.cb.call(this.scope);\n  }\n\n  return this;\n};\n/**\n * Copies x and y into the given point\n *\n * @param {PIXI.IPoint} p - The point to copy.\n * @returns {PIXI.IPoint} Given point with values updated\n */\n\n\nObservablePoint.prototype.copyTo = function copyTo(p) {\n  p.set(this._x, this._y);\n  return p;\n};\n/**\n * Returns true if the given point is equal to this point\n *\n * @param {PIXI.IPoint} p - The point to check\n * @returns {boolean} Whether the given point equal to this point\n */\n\n\nObservablePoint.prototype.equals = function equals(p) {\n  return p.x === this._x && p.y === this._y;\n};\n/**\n * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n *\n * @member {number}\n */\n\n\nprototypeAccessors.x.get = function () {\n  return this._x;\n};\n\nprototypeAccessors.x.set = function (value) // eslint-disable-line require-jsdoc\n{\n  if (this._x !== value) {\n    this._x = value;\n    this.cb.call(this.scope);\n  }\n};\n/**\n * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n *\n * @member {number}\n */\n\n\nprototypeAccessors.y.get = function () {\n  return this._y;\n};\n\nprototypeAccessors.y.set = function (value) // eslint-disable-line require-jsdoc\n{\n  if (this._y !== value) {\n    this._y = value;\n    this.cb.call(this.scope);\n  }\n};\n\nObject.defineProperties(ObservablePoint.prototype, prototypeAccessors);\n/**\n * A number, or a string containing a number.\n * @memberof PIXI\n * @typedef {(PIXI.Point|PIXI.ObservablePoint)} IPoint\n */\n\n/**\n * Two Pi.\n *\n * @static\n * @constant {number} PI_2\n * @memberof PIXI\n */\n\nvar PI_2 = Math.PI * 2;\n/**\n * Conversion factor for converting radians to degrees.\n *\n * @static\n * @constant {number} RAD_TO_DEG\n * @memberof PIXI\n */\n\nvar RAD_TO_DEG = 180 / Math.PI;\n/**\n * Conversion factor for converting degrees to radians.\n *\n * @static\n * @constant {number} DEG_TO_RAD\n * @memberof PIXI\n */\n\nvar DEG_TO_RAD = Math.PI / 180;\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n *\n * @static\n * @constant\n * @name SHAPES\n * @memberof PIXI\n * @type {object}\n * @property {number} POLY Polygon\n * @property {number} RECT Rectangle\n * @property {number} CIRC Circle\n * @property {number} ELIP Ellipse\n * @property {number} RREC Rounded Rectangle\n */\n\nvar SHAPES = {\n  POLY: 0,\n  RECT: 1,\n  CIRC: 2,\n  ELIP: 3,\n  RREC: 4\n};\n/**\n * The PixiJS Matrix as a class makes it a lot faster.\n *\n * Here is a representation of it:\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @class\n * @memberof PIXI\n */\n\nvar Matrix = function Matrix(a, b, c, d, tx, ty) {\n  if (a === void 0) a = 1;\n  if (b === void 0) b = 0;\n  if (c === void 0) c = 0;\n  if (d === void 0) d = 1;\n  if (tx === void 0) tx = 0;\n  if (ty === void 0) ty = 0;\n  /**\n   * @member {number}\n   * @default 1\n   */\n\n  this.a = a;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.b = b;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.c = c;\n  /**\n   * @member {number}\n   * @default 1\n   */\n\n  this.d = d;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.tx = tx;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.ty = ty;\n  this.array = null;\n};\n\nvar staticAccessors = {\n  IDENTITY: {\n    configurable: true\n  },\n  TEMP_MATRIX: {\n    configurable: true\n  }\n};\n/**\n * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n *\n * a = array[0]\n * b = array[1]\n * c = array[3]\n * d = array[4]\n * tx = array[2]\n * ty = array[5]\n *\n * @param {number[]} array - The array that the matrix will be populated from.\n */\n\nMatrix.prototype.fromArray = function fromArray(array) {\n  this.a = array[0];\n  this.b = array[1];\n  this.c = array[3];\n  this.d = array[4];\n  this.tx = array[2];\n  this.ty = array[5];\n};\n/**\n * sets the matrix properties\n *\n * @param {number} a - Matrix component\n * @param {number} b - Matrix component\n * @param {number} c - Matrix component\n * @param {number} d - Matrix component\n * @param {number} tx - Matrix component\n * @param {number} ty - Matrix component\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.set = function set(a, b, c, d, tx, ty) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.d = d;\n  this.tx = tx;\n  this.ty = ty;\n  return this;\n};\n/**\n * Creates an array from the current Matrix object.\n *\n * @param {boolean} transpose - Whether we need to transpose the matrix or not\n * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out\n * @return {number[]} the newly created array which contains the matrix\n */\n\n\nMatrix.prototype.toArray = function toArray(transpose, out) {\n  if (!this.array) {\n    this.array = new Float32Array(9);\n  }\n\n  var array = out || this.array;\n\n  if (transpose) {\n    array[0] = this.a;\n    array[1] = this.b;\n    array[2] = 0;\n    array[3] = this.c;\n    array[4] = this.d;\n    array[5] = 0;\n    array[6] = this.tx;\n    array[7] = this.ty;\n    array[8] = 1;\n  } else {\n    array[0] = this.a;\n    array[1] = this.c;\n    array[2] = this.tx;\n    array[3] = this.b;\n    array[4] = this.d;\n    array[5] = this.ty;\n    array[6] = 0;\n    array[7] = 0;\n    array[8] = 1;\n  }\n\n  return array;\n};\n/**\n * Get a new position with the current transformation applied.\n * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n *\n * @param {PIXI.Point} pos - The origin\n * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n * @return {PIXI.Point} The new point, transformed through this matrix\n */\n\n\nMatrix.prototype.apply = function apply(pos, newPos) {\n  newPos = newPos || new Point();\n  var x = pos.x;\n  var y = pos.y;\n  newPos.x = this.a * x + this.c * y + this.tx;\n  newPos.y = this.b * x + this.d * y + this.ty;\n  return newPos;\n};\n/**\n * Get a new position with the inverse of the current transformation applied.\n * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n *\n * @param {PIXI.Point} pos - The origin\n * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n * @return {PIXI.Point} The new point, inverse-transformed through this matrix\n */\n\n\nMatrix.prototype.applyInverse = function applyInverse(pos, newPos) {\n  newPos = newPos || new Point();\n  var id = 1 / (this.a * this.d + this.c * -this.b);\n  var x = pos.x;\n  var y = pos.y;\n  newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n  newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n  return newPos;\n};\n/**\n * Translates the matrix on the x and y.\n *\n * @param {number} x How much to translate x by\n * @param {number} y How much to translate y by\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.translate = function translate(x, y) {\n  this.tx += x;\n  this.ty += y;\n  return this;\n};\n/**\n * Applies a scale transformation to the matrix.\n *\n * @param {number} x The amount to scale horizontally\n * @param {number} y The amount to scale vertically\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.scale = function scale(x, y) {\n  this.a *= x;\n  this.d *= y;\n  this.c *= x;\n  this.b *= y;\n  this.tx *= x;\n  this.ty *= y;\n  return this;\n};\n/**\n * Applies a rotation transformation to the matrix.\n *\n * @param {number} angle - The angle in radians.\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.rotate = function rotate(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var a1 = this.a;\n  var c1 = this.c;\n  var tx1 = this.tx;\n  this.a = a1 * cos - this.b * sin;\n  this.b = a1 * sin + this.b * cos;\n  this.c = c1 * cos - this.d * sin;\n  this.d = c1 * sin + this.d * cos;\n  this.tx = tx1 * cos - this.ty * sin;\n  this.ty = tx1 * sin + this.ty * cos;\n  return this;\n};\n/**\n * Appends the given Matrix to this Matrix.\n *\n * @param {PIXI.Matrix} matrix - The matrix to append.\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.append = function append(matrix) {\n  var a1 = this.a;\n  var b1 = this.b;\n  var c1 = this.c;\n  var d1 = this.d;\n  this.a = matrix.a * a1 + matrix.b * c1;\n  this.b = matrix.a * b1 + matrix.b * d1;\n  this.c = matrix.c * a1 + matrix.d * c1;\n  this.d = matrix.c * b1 + matrix.d * d1;\n  this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n  this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n  return this;\n};\n/**\n * Sets the matrix based on all the available properties\n *\n * @param {number} x - Position on the x axis\n * @param {number} y - Position on the y axis\n * @param {number} pivotX - Pivot on the x axis\n * @param {number} pivotY - Pivot on the y axis\n * @param {number} scaleX - Scale on the x axis\n * @param {number} scaleY - Scale on the y axis\n * @param {number} rotation - Rotation in radians\n * @param {number} skewX - Skew on the x axis\n * @param {number} skewY - Skew on the y axis\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n  this.a = Math.cos(rotation + skewY) * scaleX;\n  this.b = Math.sin(rotation + skewY) * scaleX;\n  this.c = -Math.sin(rotation - skewX) * scaleY;\n  this.d = Math.cos(rotation - skewX) * scaleY;\n  this.tx = x - (pivotX * this.a + pivotY * this.c);\n  this.ty = y - (pivotX * this.b + pivotY * this.d);\n  return this;\n};\n/**\n * Prepends the given Matrix to this Matrix.\n *\n * @param {PIXI.Matrix} matrix - The matrix to prepend\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.prepend = function prepend(matrix) {\n  var tx1 = this.tx;\n\n  if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n    var a1 = this.a;\n    var c1 = this.c;\n    this.a = a1 * matrix.a + this.b * matrix.c;\n    this.b = a1 * matrix.b + this.b * matrix.d;\n    this.c = c1 * matrix.a + this.d * matrix.c;\n    this.d = c1 * matrix.b + this.d * matrix.d;\n  }\n\n  this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n  this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n  return this;\n};\n/**\n * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n *\n * @param {PIXI.Transform} transform - The transform to apply the properties to.\n * @return {PIXI.Transform} The transform with the newly applied properties\n */\n\n\nMatrix.prototype.decompose = function decompose(transform) {\n  // sort out rotation / skew..\n  var a = this.a;\n  var b = this.b;\n  var c = this.c;\n  var d = this.d;\n  var skewX = -Math.atan2(-c, d);\n  var skewY = Math.atan2(b, a);\n  var delta = Math.abs(skewX + skewY);\n\n  if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001) {\n    transform.rotation = skewY;\n    transform.skew.x = transform.skew.y = 0;\n  } else {\n    transform.rotation = 0;\n    transform.skew.x = skewX;\n    transform.skew.y = skewY;\n  } // next set scale\n\n\n  transform.scale.x = Math.sqrt(a * a + b * b);\n  transform.scale.y = Math.sqrt(c * c + d * d); // next set position\n\n  transform.position.x = this.tx;\n  transform.position.y = this.ty;\n  return transform;\n};\n/**\n * Inverts this matrix\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.invert = function invert() {\n  var a1 = this.a;\n  var b1 = this.b;\n  var c1 = this.c;\n  var d1 = this.d;\n  var tx1 = this.tx;\n  var n = a1 * d1 - b1 * c1;\n  this.a = d1 / n;\n  this.b = -b1 / n;\n  this.c = -c1 / n;\n  this.d = a1 / n;\n  this.tx = (c1 * this.ty - d1 * tx1) / n;\n  this.ty = -(a1 * this.ty - b1 * tx1) / n;\n  return this;\n};\n/**\n * Resets this Matrix to an identity (default) matrix.\n *\n * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.identity = function identity() {\n  this.a = 1;\n  this.b = 0;\n  this.c = 0;\n  this.d = 1;\n  this.tx = 0;\n  this.ty = 0;\n  return this;\n};\n/**\n * Creates a new Matrix object with the same values as this one.\n *\n * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.\n */\n\n\nMatrix.prototype.clone = function clone() {\n  var matrix = new Matrix();\n  matrix.a = this.a;\n  matrix.b = this.b;\n  matrix.c = this.c;\n  matrix.d = this.d;\n  matrix.tx = this.tx;\n  matrix.ty = this.ty;\n  return matrix;\n};\n/**\n * Changes the values of the given matrix to be the same as the ones in this matrix\n *\n * @param {PIXI.Matrix} matrix - The matrix to copy to.\n * @return {PIXI.Matrix} The matrix given in parameter with its values updated.\n */\n\n\nMatrix.prototype.copyTo = function copyTo(matrix) {\n  matrix.a = this.a;\n  matrix.b = this.b;\n  matrix.c = this.c;\n  matrix.d = this.d;\n  matrix.tx = this.tx;\n  matrix.ty = this.ty;\n  return matrix;\n};\n/**\n * Changes the values of the matrix to be the same as the ones in given matrix\n *\n * @param {PIXI.Matrix} matrix - The matrix to copy from.\n * @return {PIXI.Matrix} this\n */\n\n\nMatrix.prototype.copyFrom = function copyFrom(matrix) {\n  this.a = matrix.a;\n  this.b = matrix.b;\n  this.c = matrix.c;\n  this.d = matrix.d;\n  this.tx = matrix.tx;\n  this.ty = matrix.ty;\n  return this;\n};\n/**\n * A default (identity) matrix\n *\n * @static\n * @const\n * @member {PIXI.Matrix}\n */\n\n\nstaticAccessors.IDENTITY.get = function () {\n  return new Matrix();\n};\n/**\n * A temp matrix\n *\n * @static\n * @const\n * @member {PIXI.Matrix}\n */\n\n\nstaticAccessors.TEMP_MATRIX.get = function () {\n  return new Matrix();\n};\n\nObject.defineProperties(Matrix, staticAccessors); // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\n\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nvar tempMatrices = [];\nvar mul = [];\n\nfunction signum(x) {\n  if (x < 0) {\n    return -1;\n  }\n\n  if (x > 0) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction init() {\n  for (var i = 0; i < 16; i++) {\n    var row = [];\n    mul.push(row);\n\n    for (var j = 0; j < 16; j++) {\n      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n\n      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n\n      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n\n      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n\n      for (var k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n\n  for (var i$1 = 0; i$1 < 16; i$1++) {\n    var mat = new Matrix();\n    mat.set(ux[i$1], uy[i$1], vx[i$1], vy[i$1], 0, 0);\n    tempMatrices.push(mat);\n  }\n}\n\ninit();\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},\n * D8 is the same but with diagonals. Used for texture rotations.\n *\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n *\n * @author Ivan @ivanpopelyshev\n * @class\n * @memberof PIXI\n */\n\nvar GroupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MIRROR_HORIZONTAL: 12,\n  uX: function (ind) {\n    return ux[ind];\n  },\n  uY: function (ind) {\n    return uy[ind];\n  },\n  vX: function (ind) {\n    return vx[ind];\n  },\n  vY: function (ind) {\n    return vy[ind];\n  },\n  inv: function (rotation) {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n\n    return -rotation & 7;\n  },\n  add: function (rotationSecond, rotationFirst) {\n    return mul[rotationSecond][rotationFirst];\n  },\n  sub: function (rotationSecond, rotationFirst) {\n    return mul[rotationSecond][GroupD8.inv(rotationFirst)];\n  },\n\n  /**\n   * Adds 180 degrees to rotation. Commutative operation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} rotated number\n   */\n  rotate180: function (rotation) {\n    return rotation ^ 4;\n  },\n\n  /**\n   * Direction of main vector can be horizontal, vertical or diagonal.\n   * Some objects work with vertical directions different.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: function (rotation) {\n    return (rotation & 3) === 2;\n  },\n\n  /**\n   * @memberof PIXI.GroupD8\n   * @param {number} dx - TODO\n   * @param {number} dy - TODO\n   *\n   * @return {number} TODO\n   */\n  byDirection: function (dx, dy) {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return GroupD8.S;\n      }\n\n      return GroupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return GroupD8.E;\n      }\n\n      return GroupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return GroupD8.SE;\n      }\n\n      return GroupD8.SW;\n    } else if (dx > 0) {\n      return GroupD8.NE;\n    }\n\n    return GroupD8.NW;\n  },\n\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {number} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: function (matrix, rotation, tx, ty) {\n    if (tx === void 0) tx = 0;\n    if (ty === void 0) ty = 0; // Packer used \"rotation\", we use \"inv(rotation)\"\n\n    var mat = tempMatrices[GroupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n/**\n * Transform that takes care about its versions\n *\n * @class\n * @memberof PIXI\n */\n\nvar Transform = function Transform() {\n  /**\n   * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n   *\n   * @member {PIXI.Matrix}\n   */\n  this.worldTransform = new Matrix();\n  /**\n   * The local matrix transform\n   *\n   * @member {PIXI.Matrix}\n   */\n\n  this.localTransform = new Matrix();\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   *\n   * @member {PIXI.ObservablePoint}\n   */\n\n  this.position = new ObservablePoint(this.onChange, this, 0, 0);\n  /**\n   * The scale factor of the object.\n   *\n   * @member {PIXI.ObservablePoint}\n   */\n\n  this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n  /**\n   * The pivot point of the displayObject that it rotates around.\n   *\n   * @member {PIXI.ObservablePoint}\n   */\n\n  this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n  /**\n   * The skew amount, on the x and y axis.\n   *\n   * @member {PIXI.ObservablePoint}\n   */\n\n  this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n  this._rotation = 0;\n  this._cx = 1; // cos rotation + skewY;\n\n  this._sx = 0; // sin rotation + skewY;\n\n  this._cy = 0; // cos rotation + Math.PI/2 - skewX;\n\n  this._sy = 1; // sin rotation + Math.PI/2 - skewX;\n\n  this._localID = 0;\n  this._currentLocalID = 0;\n  this._worldID = 0;\n  this._parentID = 0;\n};\n\nvar prototypeAccessors$1 = {\n  rotation: {\n    configurable: true\n  }\n};\n/**\n * Called when a value changes.\n *\n * @private\n */\n\nTransform.prototype.onChange = function onChange() {\n  this._localID++;\n};\n/**\n * Called when skew or rotation changes\n *\n * @private\n */\n\n\nTransform.prototype.updateSkew = function updateSkew() {\n  this._cx = Math.cos(this._rotation + this.skew._y);\n  this._sx = Math.sin(this._rotation + this.skew._y);\n  this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2\n\n  this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2\n\n  this._localID++;\n};\n/**\n * Updates only local matrix\n */\n\n\nTransform.prototype.updateLocalTransform = function updateLocalTransform() {\n  var lt = this.localTransform;\n\n  if (this._localID !== this._currentLocalID) {\n    // get the matrix values of the displayobject based on its transform properties..\n    lt.a = this._cx * this.scale._x;\n    lt.b = this._sx * this.scale._x;\n    lt.c = this._cy * this.scale._y;\n    lt.d = this._sy * this.scale._y;\n    lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);\n    lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);\n    this._currentLocalID = this._localID; // force an update..\n\n    this._parentID = -1;\n  }\n};\n/**\n * Updates the values of the object and applies the parent's transform.\n *\n * @param {PIXI.Transform} parentTransform - The transform of the parent of this object\n */\n\n\nTransform.prototype.updateTransform = function updateTransform(parentTransform) {\n  var lt = this.localTransform;\n\n  if (this._localID !== this._currentLocalID) {\n    // get the matrix values of the displayobject based on its transform properties..\n    lt.a = this._cx * this.scale._x;\n    lt.b = this._sx * this.scale._x;\n    lt.c = this._cy * this.scale._y;\n    lt.d = this._sy * this.scale._y;\n    lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);\n    lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);\n    this._currentLocalID = this._localID; // force an update..\n\n    this._parentID = -1;\n  }\n\n  if (this._parentID !== parentTransform._worldID) {\n    // concat the parent matrix with the objects transform.\n    var pt = parentTransform.worldTransform;\n    var wt = this.worldTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this._parentID = parentTransform._worldID; // update the id of the transform..\n\n    this._worldID++;\n  }\n};\n/**\n * Decomposes a matrix and sets the transforms properties based on it.\n *\n * @param {PIXI.Matrix} matrix - The matrix to decompose\n */\n\n\nTransform.prototype.setFromMatrix = function setFromMatrix(matrix) {\n  matrix.decompose(this);\n  this._localID++;\n};\n/**\n * The rotation of the object in radians.\n *\n * @member {number}\n */\n\n\nprototypeAccessors$1.rotation.get = function () {\n  return this._rotation;\n};\n\nprototypeAccessors$1.rotation.set = function (value) // eslint-disable-line require-jsdoc\n{\n  if (this._rotation !== value) {\n    this._rotation = value;\n    this.updateSkew();\n  }\n};\n\nObject.defineProperties(Transform.prototype, prototypeAccessors$1);\nTransform.IDENTITY = new Transform();\n/**\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\n * point (x, y) and by its width and its height.\n *\n * @class\n * @memberof PIXI\n */\n\nvar Rectangle = function Rectangle(x, y, width, height) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (width === void 0) width = 0;\n  if (height === void 0) height = 0;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.x = Number(x);\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.y = Number(y);\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.width = Number(width);\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.height = Number(height);\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   * @readOnly\n   * @default PIXI.SHAPES.RECT\n   * @see PIXI.SHAPES\n   */\n\n  this.type = SHAPES.RECT;\n};\n\nvar prototypeAccessors$2 = {\n  left: {\n    configurable: true\n  },\n  right: {\n    configurable: true\n  },\n  top: {\n    configurable: true\n  },\n  bottom: {\n    configurable: true\n  }\n};\nvar staticAccessors$1 = {\n  EMPTY: {\n    configurable: true\n  }\n};\n/**\n * returns the left edge of the rectangle\n *\n * @member {number}\n */\n\nprototypeAccessors$2.left.get = function () {\n  return this.x;\n};\n/**\n * returns the right edge of the rectangle\n *\n * @member {number}\n */\n\n\nprototypeAccessors$2.right.get = function () {\n  return this.x + this.width;\n};\n/**\n * returns the top edge of the rectangle\n *\n * @member {number}\n */\n\n\nprototypeAccessors$2.top.get = function () {\n  return this.y;\n};\n/**\n * returns the bottom edge of the rectangle\n *\n * @member {number}\n */\n\n\nprototypeAccessors$2.bottom.get = function () {\n  return this.y + this.height;\n};\n/**\n * A constant empty rectangle.\n *\n * @static\n * @constant\n * @member {PIXI.Rectangle}\n */\n\n\nstaticAccessors$1.EMPTY.get = function () {\n  return new Rectangle(0, 0, 0, 0);\n};\n/**\n * Creates a clone of this Rectangle\n *\n * @return {PIXI.Rectangle} a copy of the rectangle\n */\n\n\nRectangle.prototype.clone = function clone() {\n  return new Rectangle(this.x, this.y, this.width, this.height);\n};\n/**\n * Copies another rectangle to this one.\n *\n * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.\n * @return {PIXI.Rectangle} Returns itself.\n */\n\n\nRectangle.prototype.copyFrom = function copyFrom(rectangle) {\n  this.x = rectangle.x;\n  this.y = rectangle.y;\n  this.width = rectangle.width;\n  this.height = rectangle.height;\n  return this;\n};\n/**\n * Copies this rectangle to another one.\n *\n * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.\n * @return {PIXI.Rectangle} Returns given parameter.\n */\n\n\nRectangle.prototype.copyTo = function copyTo(rectangle) {\n  rectangle.x = this.x;\n  rectangle.y = this.y;\n  rectangle.width = this.width;\n  rectangle.height = this.height;\n  return rectangle;\n};\n/**\n * Checks whether the x and y coordinates given are contained within this Rectangle\n *\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Rectangle\n */\n\n\nRectangle.prototype.contains = function contains(x, y) {\n  if (this.width <= 0 || this.height <= 0) {\n    return false;\n  }\n\n  if (x >= this.x && x < this.x + this.width) {\n    if (y >= this.y && y < this.y + this.height) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Pads the rectangle making it grow in all directions.\n *\n * @param {number} paddingX - The horizontal padding amount.\n * @param {number} paddingY - The vertical padding amount.\n */\n\n\nRectangle.prototype.pad = function pad(paddingX, paddingY) {\n  paddingX = paddingX || 0;\n  paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);\n  this.x -= paddingX;\n  this.y -= paddingY;\n  this.width += paddingX * 2;\n  this.height += paddingY * 2;\n};\n/**\n * Fits this rectangle around the passed one.\n *\n * @param {PIXI.Rectangle} rectangle - The rectangle to fit.\n */\n\n\nRectangle.prototype.fit = function fit(rectangle) {\n  var x1 = Math.max(this.x, rectangle.x);\n  var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n  var y1 = Math.max(this.y, rectangle.y);\n  var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n  this.x = x1;\n  this.width = Math.max(x2 - x1, 0);\n  this.y = y1;\n  this.height = Math.max(y2 - y1, 0);\n};\n/**\n * Enlarges rectangle that way its corners lie on grid\n *\n * @param {number} [resolution=1] resolution\n * @param {number} [eps=0.001] precision\n */\n\n\nRectangle.prototype.ceil = function ceil(resolution, eps) {\n  if (resolution === void 0) resolution = 1;\n  if (eps === void 0) eps = 0.001;\n  var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n  var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n  this.x = Math.floor((this.x + eps) * resolution) / resolution;\n  this.y = Math.floor((this.y + eps) * resolution) / resolution;\n  this.width = x2 - this.x;\n  this.height = y2 - this.y;\n};\n/**\n * Enlarges this rectangle to include the passed rectangle.\n *\n * @param {PIXI.Rectangle} rectangle - The rectangle to include.\n */\n\n\nRectangle.prototype.enlarge = function enlarge(rectangle) {\n  var x1 = Math.min(this.x, rectangle.x);\n  var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n  var y1 = Math.min(this.y, rectangle.y);\n  var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n  this.x = x1;\n  this.width = x2 - x1;\n  this.y = y1;\n  this.height = y2 - y1;\n};\n\nObject.defineProperties(Rectangle.prototype, prototypeAccessors$2);\nObject.defineProperties(Rectangle, staticAccessors$1);\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n *\n * @class\n * @memberof PIXI\n */\n\nvar Circle = function Circle(x, y, radius) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (radius === void 0) radius = 0;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.x = x;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.y = y;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.radius = radius;\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   * @readOnly\n   * @default PIXI.SHAPES.CIRC\n   * @see PIXI.SHAPES\n   */\n\n  this.type = SHAPES.CIRC;\n};\n/**\n * Creates a clone of this Circle instance\n *\n * @return {PIXI.Circle} a copy of the Circle\n */\n\n\nCircle.prototype.clone = function clone() {\n  return new Circle(this.x, this.y, this.radius);\n};\n/**\n * Checks whether the x and y coordinates given are contained within this circle\n *\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Circle\n */\n\n\nCircle.prototype.contains = function contains(x, y) {\n  if (this.radius <= 0) {\n    return false;\n  }\n\n  var r2 = this.radius * this.radius;\n  var dx = this.x - x;\n  var dy = this.y - y;\n  dx *= dx;\n  dy *= dy;\n  return dx + dy <= r2;\n};\n/**\n* Returns the framing rectangle of the circle as a Rectangle object\n*\n* @return {PIXI.Rectangle} the framing rectangle\n*/\n\n\nCircle.prototype.getBounds = function getBounds() {\n  return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n};\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar Ellipse = function Ellipse(x, y, halfWidth, halfHeight) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (halfWidth === void 0) halfWidth = 0;\n  if (halfHeight === void 0) halfHeight = 0;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.x = x;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.y = y;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.width = halfWidth;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.height = halfHeight;\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   * @readOnly\n   * @default PIXI.SHAPES.ELIP\n   * @see PIXI.SHAPES\n   */\n\n  this.type = SHAPES.ELIP;\n};\n/**\n * Creates a clone of this Ellipse instance\n *\n * @return {PIXI.Ellipse} a copy of the ellipse\n */\n\n\nEllipse.prototype.clone = function clone() {\n  return new Ellipse(this.x, this.y, this.width, this.height);\n};\n/**\n * Checks whether the x and y coordinates given are contained within this ellipse\n *\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coords are within this ellipse\n */\n\n\nEllipse.prototype.contains = function contains(x, y) {\n  if (this.width <= 0 || this.height <= 0) {\n    return false;\n  } // normalize the coords to an ellipse with center 0,0\n\n\n  var normx = (x - this.x) / this.width;\n  var normy = (y - this.y) / this.height;\n  normx *= normx;\n  normy *= normy;\n  return normx + normy <= 1;\n};\n/**\n * Returns the framing rectangle of the ellipse as a Rectangle object\n *\n * @return {PIXI.Rectangle} the framing rectangle\n */\n\n\nEllipse.prototype.getBounds = function getBounds() {\n  return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n};\n/**\n * A class to define a shape via user defined co-orinates.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar Polygon = function Polygon() {\n  var points = [],\n      len = arguments.length;\n\n  while (len--) points[len] = arguments[len];\n\n  if (Array.isArray(points[0])) {\n    points = points[0];\n  } // if this is an array of points, convert it to a flat array of numbers\n\n\n  if (points[0] instanceof Point) {\n    var p = [];\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      p.push(points[i].x, points[i].y);\n    }\n\n    points = p;\n  }\n  /**\n   * An array of the points of this polygon\n   *\n   * @member {number[]}\n   */\n\n\n  this.points = points;\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   * @readOnly\n   * @default PIXI.SHAPES.POLY\n   * @see PIXI.SHAPES\n   */\n\n  this.type = SHAPES.POLY;\n  /**\n   * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.\n   * @member {boolean}\n   * @default true\n   */\n\n  this.closeStroke = true;\n};\n/**\n * Creates a clone of this polygon\n *\n * @return {PIXI.Polygon} a copy of the polygon\n */\n\n\nPolygon.prototype.clone = function clone() {\n  var polygon = new Polygon(this.points.slice());\n  polygon.closeStroke = this.closeStroke;\n  return polygon;\n};\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this polygon\n */\n\n\nPolygon.prototype.contains = function contains(x, y) {\n  var inside = false; // use some raycasting to test hits\n  // https://github.com/substack/point-in-polygon/blob/master/index.js\n\n  var length = this.points.length / 2;\n\n  for (var i = 0, j = length - 1; i < length; j = i++) {\n    var xi = this.points[i * 2];\n    var yi = this.points[i * 2 + 1];\n    var xj = this.points[j * 2];\n    var yj = this.points[j * 2 + 1];\n    var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n/**\n * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its\n * top-left corner point (x, y) and by its width and its height and its radius.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar RoundedRectangle = function RoundedRectangle(x, y, width, height, radius) {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (width === void 0) width = 0;\n  if (height === void 0) height = 0;\n  if (radius === void 0) radius = 20;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.x = x;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.y = y;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.width = width;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.height = height;\n  /**\n   * @member {number}\n   * @default 20\n   */\n\n  this.radius = radius;\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   * @readonly\n   * @default PIXI.SHAPES.RREC\n   * @see PIXI.SHAPES\n   */\n\n  this.type = SHAPES.RREC;\n};\n/**\n * Creates a clone of this Rounded Rectangle\n *\n * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle\n */\n\n\nRoundedRectangle.prototype.clone = function clone() {\n  return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n};\n/**\n * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n *\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle\n */\n\n\nRoundedRectangle.prototype.contains = function contains(x, y) {\n  if (this.width <= 0 || this.height <= 0) {\n    return false;\n  }\n\n  if (x >= this.x && x <= this.x + this.width) {\n    if (y >= this.y && y <= this.y + this.height) {\n      if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) {\n        return true;\n      }\n\n      var dx = x - (this.x + this.radius);\n      var dy = y - (this.y + this.radius);\n      var radius2 = this.radius * this.radius;\n\n      if (dx * dx + dy * dy <= radius2) {\n        return true;\n      }\n\n      dx = x - (this.x + this.width - this.radius);\n\n      if (dx * dx + dy * dy <= radius2) {\n        return true;\n      }\n\n      dy = y - (this.y + this.height - this.radius);\n\n      if (dx * dx + dy * dy <= radius2) {\n        return true;\n      }\n\n      dx = x - (this.x + this.radius);\n\n      if (dx * dx + dy * dy <= radius2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Math classes and utilities mixed into PIXI namespace.\n *\n * @lends PIXI\n */\n\n\nexport { Circle, DEG_TO_RAD, Ellipse, GroupD8, Matrix, ObservablePoint, PI_2, Point, Polygon, RAD_TO_DEG, Rectangle, RoundedRectangle, SHAPES, Transform };","map":null,"metadata":{},"sourceType":"module"}